<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[勇冠三军当去病，文武双全唯弃疾]]></title>
    <url>%2Fpost%2Fb55ce8c8.html</url>
    <content type="text"><![CDATA[​ 思汉之霍去病勇冠三军，惜其天妒英才​ 念宋时辛弃疾文武双全，叹之壮志未酬 2020年霍去病和辛弃疾取代秦琼和尉迟恭，成为家家户户的左右门神，护佑着我华夏儿女，望我们早日渡过难关！ 鲲鲲我对二位大佬的人生履历十分好奇，查阅资料后发现他们真的是当之无愧的华夏守护神！ 一 思汉之霍去病勇冠三军，惜其天妒英才 公元前140年，西汉的第七位皇帝刘彻登基，也就是我们熟知的汉武大帝，此时武帝17岁，以“建元”为年号，自此中国历史以年号纪元。 建元有创始的寓意，这正表明了一代雄主锐意变革的壮志，一个大世即将拉开帷幕！ 同一年，武帝的同胞长姐平阳公主府中，女奴卫少儿生下了一个私生子。 卫少儿是谁呢？ 或许很多人不知晓，她就是卫子夫和卫青的二姐，而这个私生子就是霍去病。 汉武帝建元二年（前139年），卫子夫得幸武帝，入宫一年后日益深得天子宠爱。 在霍去病十一二岁的时候，卫子夫被立为当朝皇后，卫子夫一家因此贵幸。 霍去病虽出身卑微，但在年幼之时便进入上流社会，从小就能受到良好的教育，爱屋及乌之下，武帝很是喜欢这个善于骑射的少年郎，甚至想要亲自教他孙吴兵法，但被霍去病以“战争只用看方针策略即可，要创造性地去指挥作战，无需拘泥于古法”的理由给无情的拒绝掉。 《史记·卫将军骠骑列传》： 骠骑将军为人少言不泄，有气敢任。 天子尝欲教之孙吴兵法，对曰： “顾方略何如耳，不至学古兵法。 大佬就是大佬，果然不同凡响，后来果然用吊打匈奴的实际战果证明了其堪称完美的军事能力。 从小深受武帝喜爱，这是霍去病日后能早早开启传奇人生的先决条件，也是千年之后的辛弃疾所享受不到的待遇。 这是一个崇勇尙武的朝代； 这是一个 寇可为，我复亦为； 寇可往，我复亦往的朝代； 这是一个明犯强汉者，虽远必诛的朝代； 这是一个四方夷狄不敢小视中国的朝代。 武帝一朝大破匈奴，远征大宛，降服西域，收复南越，吞并朝鲜，大汉疆土东抵日本海、南吞交趾、西逾葱岭、北达阴山， 汉之魂将永垂不朽。 战争，或对于底层百姓来说或许是不幸的，但对于霍去病这样的热血男儿来说却是建功立业的大好时代，我们就一起来看看霍去病开挂的传奇人生吧！ 一战封侯 &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;借问大将谁，恐是霍嫖姚。 &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ——&nbsp; &nbsp;杜甫 元朔六年(前123年），这一年刘彻34岁，正值壮年，汉武帝再次筹划了对匈奴的一次大规模反击战，史称漠南之战。 17岁的霍去病主动请缨，武帝封他为“嫖姚校尉”随军出征，这是武帝特地给他初创的名号，“嫖”是轻捷的意思，“姚”是美好的意思。 就是又轻又快又美！ 看着霍去病远去的身影，武帝或许回忆起当初自己登基时的场景吧，那年的他同样是17岁，也是如此的意气风发啊！ 这次战役的主帅是他舅舅卫青，霍去病想大展身手，再三地要求卫青拨兵给他，吵着要单干。 卫青架不住，就当哄小孩子了，便从三十万大军中点了八百骑兵让他统领。 不说一般人，就是一些名将，也很难用数百兵卒折腾点东西出来。 而大神就是大神，凭着他那丰富的想象力，霍去病率领自己的麾下骑兵在茫茫大漠上“长途奔袭”，奇袭敌方水晶，首战告捷，顺利拿到一血。 此次战役斩敌共两千零八十二人，含匈奴相国等高级官员，俘虏了匈奴单于叔父罗姑比，“霍去病”这三个大字横空出世，将成为匈奴人的噩梦。 霍去病两次功冠三军，武帝愈加喜爱，划定一千六百户封霍去病为冠军侯，后世之人皆以冠军为荣。 两战河西 西归大河，列郡祁连 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;—— 班固 两年后的春天(前121年），19岁的霍去病被汉武帝刘彻寄予厚望，封其为骠骑将军，“骠”有马行疾貌的意思。 带着汉武帝的期待和信任，这次霍去病独自统领一万骠骑从陇西出发兵讨匈奴，再次开始了他的表演，在千里大漠中发动闪电奔袭战。 六天中霍骠骑横扫河西匈奴诸部落，一路高歌猛进千余里，后来在皋兰山下和匈奴卢侯王、折兰王硬碰硬，以一敌二并顺利完成二杀。 此次战役是极其惨烈的，一万精兵最后也只有三千人凯旋归来，但此次霍去病共歼敌近九千人，尽数俘虏浑邪王子及相国、都尉，缴获的战利品中更是有匈奴人祭天的金人。 同年夏天，霍去病和公孙敖等率领数万大军，在武帝的旨意下准备收复河西，分兵之后的公孙敖居然在大漠中迷了路，不知是公孙敖太菜还是霍去病太牛逼，我想应该是后者吧，因为飞将军李广和张骞两位大佬作为策应部队同样也没跟上霍骠骑的节奏。 没有辅助，霍去病没有退缩，果断孤军深入，直推敌方水晶，力挽狂澜，取得大捷。 这次歼敌三万余人，俘虏五个匈奴王及其王母，大小单于阏氏、王子五十九人，相国、将军、当户、都尉六十三人，汉军仅仅伤亡三千人。 我们或许听过《三国演义》中的关羽关云长单刀赴会，但那毕竟是文学加工后的故事，但我们的冠军侯却实实在在地秀了一把个人勇武。 匈奴单于伊稚斜(yī zhì chá)在得知两场河西战役失利后大片领土丢失，将要严厉惩处浑邪王、休屠王。 消息走漏，二王恐惧之下想要跑路，奈何草原无处去，只好派使者向大汉乞降。 还未到河西之时，休屠王临时变卦，拒绝降汉，浑邪王攻杀休屠王，收编其部众，但人心极不稳定。 同年秋，霍去病率1万兵马奉旨前去受降， 刚到黄河边的时候，只见匈奴降部中忽然发生了哗变，局势即将不可控。 在这紧急关头，霍去病当机立断，只带数名亲兵冲进匈奴大营中，喝令浑邪王诛杀哗变士卒八千余人，这下匈奴军队才稳定下来。 然后先遣使送浑邪王赴长安觐见汉武帝，自己则接管匈奴四万余众向大汉边境缓行。 经过霍去病指挥的两场河西之战，大汉自此打通河西走廊，先后设置武威、酒泉、张掖、敦煌四郡。 匈奴为此悲歌： “失我祁连山，使我六畜不蕃息； 失我焉支山，使我嫁妇无颜色。 ”这时候他才19岁啊，就取得了如此赫赫战功，马踏匈奴，缴获祭天金人，使华夏政权第一次占据河西，为丝绸之路奠定基础。 三战漠北 饮马瀚海，封狼居胥 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; —— 班固 元狩四年（公元前117），此时河西之战已过去两年，武帝为彻底铲平匈奴主力，发动了规模空前的漠北之战。 时年21岁的霍去病当仁不让地成为刘彻手中的王炸，霍去病这张王牌，武帝是准备用来炸匈奴单于主力的，然而由于情报错误，这场对局由卫青接下。 虽然霍去病错失了他最渴望的对手，但属于他的传奇故事将会继续谱写下去。 霍去病和他舅舅卫青各率五万骑兵，步兵转折踵军数十万分别从代郡和定襄出发，深入漠北，寻歼匈奴主力。 霍去病率本部兵马向北奔袭两千多里，越过离侯山，渡过弓闾河，碰上了左贤王部众，以一万五千的损失数量歼敌七万四百多人，俘虏匈奴王3人，及将军、相国、当户、都尉等83人，乘胜追杀至狼居胥山，并在狼居胥山举行了祭天封礼，于姑衍山举行祭地禅礼，这便是封狼居胥。 仪式结束后，霍去病继续乘胜追击，兵至瀚海（贝加尔湖），方才作罢，这就是饮马瀚海。 经此一战，“匈奴单于远遁，而漠南无王庭”。 此后饮马瀚海，封狼居胥更是被后世武将视为人生的最高追求和荣誉之一。 霍去病的一生是传奇的，出道即巅峰。 奈何天妒英才，元狩四年（公元前119年），年仅23岁的霍去病于长安去世，武帝悲恸不已，特许霍去病陪葬茂陵，下旨将霍去病的坟墓修成祁连山的模样，调遣河西五郡的铁甲军，列成阵沿长安一直排到 茂陵 东的霍去病墓。 谥“景桓侯”，取义“武与广地”，彰显这位爱将马踏匈奴，英勇无敌，为大汉开疆扩土的赫赫战功。 二 念宋时辛弃疾文武双全，叹之壮志未酬 提起辛弃疾，相信大家在中学时都学过他的诗词，老师告诉我们他是一个爱国诗人，是豪放派代表词人，有“词中之龙”的美称。 我也十分喜欢他笔下的词句。 “众里寻他千百度，蓦然回首，那人却在，灯火阑珊处。 ”寄托着他心中的柔情和理想的高士之风。 “醉里挑灯看剑，梦回吹角连营。 八百里分麾下炙，五十弦翻塞外声。 沙场秋点兵。 马作的卢飞快，弓如霹雳弦惊。 了却君王天下事，赢得生前身后名。 可怜白发生！ ”彰显着他渴望建功立业，为国为民的豪迈之情与赤诚之心。 “想当年，金戈铁马，气吞万里如虎。 元嘉草草，封狼居胥，赢得仓皇北顾。 ”诉说着自己报国无望的悲情。 公元1140年，比霍去病小1280岁的辛弃疾出生了。 这一年，距靖康之变已发生十三年了，金国撕毁盟约攻宋，南宋岌岌可危。 好在此时有岳飞挥师北伐，两河人民奔走相告，各地义军纷纷响应，夹击金军。 岳飞先后收复郑州、洛阳等失地，在郾城、颍昌大败金军，随后进军朱仙镇，形势一片大好。 连金人都不由发出感叹： “撼山易，憾岳家军难。 ” 可在位的宋高宗赵构却不是一个雄主，尽管他死后被其后代加谥号为受命中兴全功至德圣神武文昭仁宪孝皇帝。 这年赵构33岁，正值壮年，却毫无进取之心，只想偏安一隅，与金国议和，以十二道“金字牌”催令岳飞班师回朝，十年之功一日尽废，后来更是自毁长城，以莫须有的罪名将岳飞杀害。 尽管后世文人皆叹惋崖山之战，悼念南宋故国。 但我却不为南宋灭亡而可惜，所谓今日之因，他日之果。 一个不崇尚勇武的朝代，是精神被阉割的朝代，日后神州大地之所以全面沦失，皆由今朝所为。 若无岳飞，或许南宋早就灭亡了。 宋，“怂怂怂”，“送送送”。 与辛弃疾相比，霍去病无疑是幸运的，因为就是霍嫖姚复生，也收不回来那九州失地，最终结果怕是落得和岳元帅一个下场。 这也预示着辛弃疾从出生的那天起就没有驱除鞑虏，恢复中华的机会。 年少之时，辛弃疾所在的家乡早已沦陷，爷爷辛赞被迫在金国为官，屈辱又痛苦，但常常带着辛弃疾“登高望远，指画山河”，鼓励他不要忘却故国，长要为光复大宋尽力拼搏，还祖国一统。 辛弃疾目睹沦陷区的百姓受金军迫害，便暗暗发誓要早日驱除鞑虏，一边用心从文，一边刻苦习武，以恢复中原为己任。 1154年，十四五岁的辛弃疾由济南府保荐到燕京参加进士考试，可能准备不足，考试失败，但他本来就没有打算在金国为官，实质上是打着考试的幌子来观察敌情，跑进燕山勘察地形。 1157年，十七八岁的辛弃疾第二次参加进士考试，或许心里看不上这个进士考试，但只有拥有过的才有资本藐视它，是的，这年，他考中了金国的进士。 有时候人与人之间的差距有时候就是这么大啊，范进老先生50岁的时候还是个童生，54岁才通过乡试，中了举人，57进京会试,才中了进士。 但考试什么的对辛弃疾来说都是次要的，不是平生追求，宁做百夫长，胜过一书生。 他再次来到燕山，着手画地形图，为日后收复山河做准备。 1160年，祖父辛赞去世，或许祖父是带了遗憾逝世，想必稼轩收复故土的信念愈加坚定。 1161年秋，完颜亮率军南下入侵南宋，辛弃疾号召沦陷区两千热血男儿乘势揭竿而起，投奔由耿京领导的抗金义军。 才华横溢的辛弃疾受到耿京重用，被任命为掌书记，掌管义军印信，负责军中机要工作和联络南宋朝廷的任务。 这年他21岁，比霍去病出道晚了4年。 但若是从中了进士开始算起的话，两人差不多回到了同一起跑线，不过霍去病先天条件太优越了，因此一个年少便能封狼居胥，而另一个却一生壮志难酬。 但辛弃疾是一位不折不扣的猛人，武力值爆表，当初花和尚义端被他说服一块儿来投奔义军，由于受不了营中艰苦环境，义端偷盗了由辛弃疾保管的帅印，准备前往金营邀功，耿京盛怒之下，只得拿辛弃疾问罪。 辛弃疾自知识人不明，交友不慎，羞愧难当，当即立下军令状。 于是辛弃疾带了一小队人马连夜奔袭，埋伏在去往金营必经的路上。 果然，破晓之时，义端骑马来到，辛弃疾二话不说，一刀将叛贼义端砍下马来。 义端正要破口大骂并还击，当他看到来人是辛弃疾之后，吓得魂飞魄散，立即跪地求饶道： “我识君真相，乃青兕也，力能杀人，幸勿杀我。 ”嫉恶如仇的辛弃疾哪里会绕的这样贪生怕死的变节分子，手起刀落，义端身首异处。 在辛弃疾携印回营交付军令状后，耿京对他更加倚重，几乎言听计从。 而辛弃疾在大家眼里更是成了绝世猛兽，皆称他为“辛青兕”。 哈哈，上面这个图片还是过分夸张啦，不过其好友陈亮的这个描述才是符合辛猛人的吧——“眼光有棱，足以照映一世之豪； 背胛有负，足以荷载四国之重。 ” 1162年，22岁的辛弃疾被耿京派去前往建康奉表南归，当日被赵构召见，授辛弃疾右承务郎。 再回归的途中，得知叛徒张安国等人杀害耿京投降金人的消息后，辛弃疾视死如归，连夜率领五十骑兵直闯五万人的金军大营，活捉张安国，之后又奔驰千里，将叛贼押送到建康，交由朝廷治罪。 “壮岁旌旗拥万夫，锦襜突骑渡江初。 燕兵夜娖银胡簶，汉箭朝飞金仆姑。 ”&nbsp; 从此，辛弃疾成为了一个传说，声闻朝野，名传庙堂。 名传庙堂。 壮声英概，懦士为之兴起，百姓为之欢呼。 虽说圣天子一见三叹息，赞许他的英勇行为，可惜他碰上的不是汉武帝这样的雄主，再加上他“归正人”的尴尬身份，注定了他没有机会大展宏图，实现人生夙愿。 从25岁被任命为江阴签判步入仕途，一直到42岁被弹劾罢官，在人生锐气风发的时候，辛弃疾都没有机会亲临一线上阵杀敌，期间被频繁调动到多地担任地方官职，负责地方民政和社会治安等事务，其中平定过荆南茶商赖文政起事，又创制飞虎军以弹压湖湘。 辛弃疾的文学成就极高，但这并不是他人生的追求，文豪非所愿，但求复九州。 1207年秋，辛弃疾病逝，享年六十八岁。 临终时还大呼“杀贼！ 杀贼！ ”，含恨而去。 纵观辛弃疾这一生，当之无愧的国士无双， 他是真正的文武全才，文能提笔安天下，武能上马定乾坤。 长按识别二维码 愿诸位当去病、弃疾]]></content>
      <tags>
        <tag>历史人物</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java自学笔记]]></title>
    <url>%2Fpost%2F1770f1b2.html</url>
    <content type="text"><![CDATA[01 Java入门1.1为什么学Java 想做工程师，开发极客 1.2 Java 版本Java SE(Java Platform Standard Edition)标准版，是为开发普通桌面和商务应用程序提供解决方案。 Java EE(Java Platform Enterpriser Edition)企业版，是为开发企业级应用程序提供解决方案。 Java ME(Java Platform Micro Edition)小型版， 是为开发电子消费产品和嵌入式设备提供的解决方案。 1.3 JDKJDK(Java Development Kit),是 Java的核心，包括Java编译器，Java运行环境， Java 打包工具， Java文档生成工具等。 JRE(Java Runtime Environment),Java 运行环境。 JDK中自带了JRE. 1.3.1 JDK的安装win10 系统 64位 Oracle 官网 https://www.oracle.com/technetwork/java/javase/downloads/index.html 下载对应的JDK安装文件，我选择的是JDK 8.0 https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html， 下载前先选择 Accept License Agreement，然后Windows x64 版本 安装：一直下一步就可以，可以自定义安装路径，一般默认在C盘里。 bin目录 ： 用于 存放一些可执行程序，如Javac.exe 和 Java.exe 。 jre 目录 ： 为Java 程序提供运行环境 include 目录 ： 由于JDK是由C和C++实现的，因此用于存放C语言的头文件 lib 目录 ： library的缩写，是Java 类库或库文件 src.zip文件： src中存放了JDK核心类的源代码 1.4 环境变量JDK安装完后要进行JDK环境变量的配置，path环境变量和classpath环境变量 path环境变量：用于告知操作系统到指定路径寻找JDK classpath环境变量： 用于告知JDK到指定路径查找类文件（class文件） 1.4.1 path环境变量配置保存一系列路径，路径间用英文“；”相隔。 配置步骤： 桌面 选择我的电脑或此电脑，选择属性； 单击 高级系统设置（左上侧）； 单击 环境变量（右下侧）； JAVA_HOME的配置 系统变量(s)中，单击 新建(W)…(左下侧) 变量名(N): JAVA_HOME 变量值(V):jdk安装路径，复制或浏览目录即可，我的是安装路径是C:\Program Files\Java\jdk1.8.0_181 将JAVA_HOME配置到path环境变量中，双击path,新建%JAVA_HOME%\bin;C:\Program Files\Java\jdk1.8.0_181\bin（貌似只要路径就可以了）和C:\Program Files\Java\jre1.8.0_181\bin,（建议上移到顶端）其中%JAVA_HOME%代表环境变量JAVA_HOME的当前值 查看配置是否成功 win + R 或右键桌面左下角window图标选择运行，输入cmd ,执行javac命令,正常显示帮助信息，说明系统path环境变量配置成功。 ​ 1.4.2 classpath 环境变量配置当Java虚拟机需要运行一个类时，会在classpath环境变量中所定义的路径下寻找所需的class文件和类包。 在设置classpath环境变量时，必须在配置路径前添加“. ;”(当前目录),用于识别当前目录下的Java类，JDK5.0后会自动设置。 变量名(N): CLASSPATH 变量值(V): .;%JAVA_HOME%lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 至此，JDK的环境变量配置完毕，就可以编写Java程序啦** 1.5 第一个Java 程序1.5.1 编写第一个Java程序在桌面(随你在哪个位置，不过要命令行窗口要cd进入相应的位置）右键新建文本文档，重命名为HelloWorld.java(文件名和类名需要一致）。然后用记事本/Sublime Text /Nodepad++打开文档，编写如下Java代码。 12345class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println("我人生的第一个Java程序，哈哈哈，HelloWorld! "); &#125;&#125; 1、win + R , cmd , 在命令行窗口输入 1cd Desktop #进入桌面，即Java文件(HelloWorld.java)所在的目录 2、 javac HelloWorld.java命令，对源文件进行编译 1javac HelloWorld.java javac 命令执行完毕后，会在当前目录下（桌面）生成一个字节码文件HelloWorld.class。 3、运行Java程序 在命令行窗口输入 java HelloWorld 命令，运行HelloWorld.class文件，输出结果 1java HelloWorld 若输出中文结果乱码 修改jdk默认编码： 点击计算机→属性→高级系统设置→高级→环境变量，系统变量→新建“JAVA_TOOL_OPTIONS”变量，值为“-Dfile.encoding=UTF-8” 1.5.2 Java 程序的运行机制成功运行Java程序必须经过编译和运行两个步骤。 HelloWorld.java →编译→HelloWorld.class字节码文件 →→Java虚拟机JVM解释执行，不同的操作系统使用不同版本的JVM，跨平台，一次编写，到处运行。 1.6 Eclipse的安装和使用1.6.1 Eclipse的安装与启动Eclipse是针对Java编程的集成开发环境（IDE),本身只是一个框架和一组服务，其所有的功能都是将插件组件加入到Eclipse框架实现的。另外IntelliJ IDEA 也超级好用。 1.Eclipse的安装百度网盘 链接：https://pan.baidu.com/s/18zfhZS03G4FkQmRBSu5qVA 密码：g0c0 官网：www.eclipse.org 下载 下载好的压缩包解压保存到指定目录下就可以使用了， 2. Eclipse 的 启动解压完成后，双击目录中eclipse.exe文件即可运行，此时会弹出一个对话框，提示选择工作空间(Workspace),可以使用默认的空间也可以更改，选中Use this as the default and do not ask again复选框可以是以后启动不在进行工作空间的设置。 3、Eclipse 的工作台 Package Explorer(包资源管理器视图，最左边空白区域）：用于显示项目文件的组成结构 Editor(文本编辑器，正中间空白区域)： 用于编写代码的区域，编辑器具有代码提示，自动补全等功能 Problems(问题视图，正下方空白区域,并选择Problems）： 显示项目中的一些警告和错误 Console(控制台视图，正下方空白区域，并选择Console/控制台）：显示程序运行时的输出信息、异常和错误 Outline(大纲视图）：显示代码中类的结构 以上视图位置可以叠放在一起，也可单独出现，并且位置可以随意拖动改变布局效果 1.6.2 Eclipse 进行程序开发使用Eclipse完成HelloWorld程序的编写和运行，并在控制台上打印“Hello World!”(基本上所有语言的学习都要来下Hello World!) 1. 创建Java项目File(文件) → New(新建) → Java Project(项目),出现一个New Java Project 对话框，并按图中创建，单击Finish完成。 然后Package Explorer 视图中便会出现一个名称为chapter01的Java项目 2、 在项目下创建包在Package Explorer( 包资源管理器 )视图中，右击chapter01项目下的src文件夹，选择New（新建）→ Package（包），会出现一个New Java Package对话框，如下图。包命名通常以公司域名的反写作为前缀。 3、创建Java类右击包名，选择New( 新建）→ Class（类），会出现一个New Java Class 对话框，如图创建一个HelloWorld类。 单击完成，包下出现一个HelloWorld.java文件。 4、编写程序代码并运行创建HelloWorld类后，在文本编辑器中只写入main()方法和一条输出语句“System.out.println(“Hello World !”); 运行后Console视图中看到运行结果。 5、包的定义与使用Java 中的包(Package)是专门用来存放类(Class)的，通常功能相同的类存放在相同的包中 包的声明： 12package com.it2m.example; //使用 package 关键字声明包 public class Example01&#123;...&#125; 在开发时，一个项目可能会使用很多包，当一个包中的类需要调用另一个包中的类时，就需要使用import关键字引入需要的类。 12import 包名.类名; import 包名.*; //导入该包下的所有类 Java的核心类主要放在java包及其子包下，Java扩展的大部分类都放在javax包及其子包下。 java.util：包含Java中大量工具类、集合类等，例如Collections、List、Set 等。 java.io：包含Java输入和输出有关的类和接口。 02 Java编程基础主要是语法结构，Java基础语法部分包含变量、常量、运算符、结构语句及数组等。 2.1 Java 的基本语法2.1.1 Java 代码的基本格式在 Java 程序中，使用class关键字定义类，所有的程序代码都放在该类中，格式如下： 123修饰符 class 类名&#123; 程序代码&#125; 注意： Java 语言严格区分大小写，eg.定义类时，class不能写成Class,否则编译会报错。 每条功能执行语句的最后都必须用分号；结束。 一个连续的字符串不能分开在两行中书写，若字符串太长，将字符串分成两个字符串，用加号（+）连接，并在加号（+）处断行。eg: 123456public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println("Hello"+ "World"); &#125;&#125; 2.1.2 Java 中的注释注释，即作解释，使得代码更易理解，注释内容不会被程序解释执行。 1、单行注释对程序的某一行代码进行解释，用符号//表示。//后面的为注释内容 1int x = 1; //定义一个整型变量x 2、多行注释注释内容可以为多行，以符号/开头，以符号 /结尾 12/* int x = 1; 声明整型变量x,并初始化为1； */ 3、文档注释常用于对类和方法的说明，以符号 / 开头，以符号 */结尾。这种方式可以使用Eclipse工具将文档注释导出并生成帮助文档，方便他人使用。 123/ * * * Person实体类 * / 2.1.3 Java 中的 标识符编写程序的过程中，经常需要定义特殊符号来标记一些名称，如包名、类名、变量名、方法名以及参数名等，这些符号被称之为标识符。 标识符可以由字母、数字、美元符号($)和下划线(_)组成，但不能以数字开头，也不可以用 Java 中的关键字 类名和接口名每个单词首字母一律大写 , Animal 包名所有字母一律小写，com.it2m.chapter02 常量名所有字母一律大写，单词之间用下划线连接, MY_SCORE 变量名和方法名的第一个单词首字母小写，从第二个单词开始每个单词首字母大写，studentName 为了程序代码便于阅读，应该定义有实际意义的英文单词以定义标识符 2.1.4 Java 中的关键字关键字是编程语言中已经定义好的并具有特殊含义的单词，都是小写，Java中所有关键字： abstract continue for new switch assert default goto package synchronized boolean do if private this break double implements protected throw byte else import public throws case enum instanceof return transient catch extends int short try char final interface static void class finally long strictfp volatile const float native super while 2.2 Java 中的变量在程序运行期间，随时可能产生一些临时数据，应用程序会将这些数据保存在一些内存单元中，每个内存单元都用一个标识符标识。这些内存单元被称为变量，定义的标识符就是变量名，内存单元中存储的数据就是变量的值。 123int x = 3; //定义int类型变量x,x的初始值为3int y; //定义了int类型变量y,y无初始值y = x - 1; //将x-1的结果赋值给y,此时y的值为2 2.2.1 变量的数据类型（两种） 1、整数类型变量 四种：字节型(byte)、短整型(short)、整型(int)、长整型(long) 12int num = 3; //定义int类型的变量并赋值为3long num = 2300000000L; //所赋的值超出了int类型的取值范围，后面必须加上L 2、浮点数类型变量 用于存储小数数值，两种：单精度浮点数(float)和双精度浮点数(double，更精确) 12float f = 111.2f; //为一个float类型的变量赋值，后面必须加上fdouble d = 111.2; //为一个double类型的变量赋值，后面可以省略d 3、布尔类型变量 true 和 false 12boolean b = false; //声明一个boolean类型的变量b，初始值为falseb = true; //改变b变量的值为true 4、字符类型变量 存储单一字符,char类型表示，Java 中每个char类型的字符变量都会占用2个字节。 1char c = 'b'; //为一个char类型的变量赋值字符b,('')为一对英文半角格式的单引号 2.2.2 变量的类型转换在程序中，当把一种数据类型的值赋给另一种数据类型的变量时，需要进行数据类型转换。 两种: 自动类型转换和强制类型转换。 1. 自动数据类型转换 ( 隐式类型转换 )指的是两种数据类型在转换过程中不需要显示地进行声明。同时满足两个条件，第一是两种数据类型彼此兼容，第二是目标类型的取值范围大于原类型的取值范围（小到大，int类型的取值范围大于byte类型取值范围） 12byte b = 1;int i = b; //程序把byte类型的变量b转换成了int类型，无须特殊声明 2.强制类型转换 ( 显示类型转换 )两种类型彼此不兼容或目标类型取值范围小于原类型时，将无法进行自动类型转换，此时需要强制类型转换。 123目标类型 变量名 = （目标类型）值int i = 5;byte b = (byte)i; 2.2.3 变量的作用域在程序中，变量一定会被定义在某一对大括号中，该大括号所包含的代码区域就是这个变量的作用域，变量只能在这个区域起作用。 123456class Hello&#123; int x = 1; public static void main(String[] args)&#123; int y = 2; &#125;&#125; 上述代码中，有两层大括号，其中，外层大括号所标识的代码区域就是x变量的作用域，内层大括号所标识的代码区域就是变量y的作用域。 2.3 Java 中的常量常量就是在程序中固定不变的值，例如数字1、字符‘a’等，常量包括整型常量，浮点数常量(1.2f, 1F, 1.23d,1.6)、布尔常量、字符常量,null常量( 表示对象的引用为空）等。 2.4 Java 中的运算符运算符用于对数据进行算数运算、赋值和比较等操作。 2.4.1 算数运算符(+,-)正负，（+，-）加减，（*，/）乘除，（%）取模，即算术的求余数 自增（++）—将操作数加1，自减（—）—将操作数减1 ， 先自增再赋值 自增（前） a=2;b=++a; a=3;b=3; 先赋值在自增 自增（后） a=2;b=a++; a=3;b=2; 先自减再赋值 自减（前） a=2;b=—a; a=1;b=1; 先赋值在自减 自减（后） a=2;b=a—; a=1;b=2; 2.4.2 赋值运算符将常量、变量或表达式的值赋给某一个变量 运算符 运算 范例 结果结果 = 赋值 a=3;b=2; a=3;b=2; += 加等于 a=3;b=2; a += b; a=a + b=5;b=2; -= 减等于 a=3;b=2; a -= b; a=a - b=1;b=2; *= 乘等于 a=3;b=2; a *= b; a=a * b=6;b=2; /= 除等于 a=3;b=2; a /= b; a=a / b=1;b=2; %= 模等于 a=3;b=2; a %= b; a=a % b=1;b=2; 2.4.3 比较运算符用于对两个数值或变量进行比较，其结果是一个布尔值，即 true 或者 false ==(相等于)，!=（不等于）, &lt;(小于)、&gt;(大于)、 &lt;=(小于等于)、&gt;=(大于等于) 2.4.5 位运算符用于对布尔型的数据进行操作，其结果仍是一个布尔值 位运算符，应用于int,long,short,char,byte等类型，不过要用二进制，假设a=60,b=13,二进制如下 1234567A = 0011 1100B = 0000 1101-----------------A&amp;B = 0000 1100A | B = 0011 1101A ^ B = 0011 0001~A= 1100 0011 下表列出了位运算符的基本运算,假设整数变量A的值为60和变量B的值为13： 操作符 描述 例子 ＆（位与） 如果相对应位都是1，则结果为1，否则为0 （A＆B），得到12，即0000 1100 \ (位或) 如果相对应位都是0，则结果为0，否则为1 （A \ B）得到61，即 0011 1101 ^（异或） 如果相对应位值相同，则结果为0，否则为1 （A ^ B）得到49，即 0011 0001 〜 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。 （〜A）得到-61，即1100 0011 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 A &lt;&lt; 2得到240，即 1111 0000 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 A &gt;&gt; 2得到15即 1111 &gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 A&gt;&gt;&gt;2得到15即0000 1111 2.4.6逻辑运算符下表列出了逻辑运算符的基本运算，假设布尔变量A为真，变量B为假 操作符 描述 例子 &amp;&amp; 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 （A &amp;&amp; B）为假。 \ \ 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 （A \ \ B）为真。 ！ 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 ！（A &amp;&amp; B）为真。 2.4.7 运算符的优先级表达式中所有运算符参与运算的先后顺序 2.5 选择结构语句2.5.1 if 条件语句1. if 语句123if(布尔表达式)&#123; //如果布尔表达式为true将执行的语句&#125; 2. if…else语句f 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行 12345if(布尔表达式)&#123; //如果布尔表达式的值为真，执行语句1&#125;else&#123; //否则执行语句2&#125; 3. if…else if…else 语句123456789101112if(布尔表达式 1)&#123; //如果布尔表达式 1的值为true执行语句1&#125;else if(布尔表达式 2)&#123; //如果布尔表达式 2的值为true执行语句2 . . .&#125;else if(布尔表达式 n)&#123; //如果布尔表达式 n的值为true执行语句n&#125;else &#123; //如果以上布尔表达式都不为true执行语句n+1&#125; 另外，嵌套的if…else语句也是合法的 2.5.2 switch case 条件语句switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。 12345678910111213141516switch(expression)&#123; case value 1: 执行语句1 break; case value 2: 执行语句2 break; . . . case value n: 执行语句n break; default : 执行语句n+1&#125; switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。 switch case 语句有如下规则： switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。 switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。 case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。 switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。 2.6 循环结构语句顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次,，就需要使用循环结构。 Java中有三种主要的循环结构： while 循环 do…while 循环 for 循环 2.6.1 while 循环只要循环条件成立（布尔表达式为true)，循环就会一直执行下去，直到条件不成立，while循环结束,它的语法结构为： 123while(循环条件)&#123; //循环内容&#125; 2.6.2 do…while循环对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。 do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。 123do &#123; //代码语句&#125;while(循环条件)； 注意：布尔表达式( 循环条件）在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。 2.6.3 for 循环一般用于执行前就确定循环次数的情况，语法格式如下： 1234for(1初始化表达式; 2循环条件; 3操作表达式)&#123; // 执行语句4&#125;5 {}中执行语句为循环体，注意for关键字后()中内容用分号( ; )分隔。 最先执行初始化步骤1。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。 然后，检测布尔表达式的值2。如果为 true，循环体被执行4。如果为false，循环终止，开始执行循环体后面的语句5。 执行一次循环4后，更新循环控制变量3。 再次检测布尔表达式2。循环执行上面的过程。 123456789public class Test &#123; public static void main(String args[]) &#123; for(int x = 10; x &lt; 20; x = x+1) &#123; System.out.print("value of x : " + x ); System.out.print("\n"); &#125; &#125;&#125; 编译结果 12345678910value of x : 10value of x : 11value of x : 12value of x : 13value of x : 14value of x : 15value of x : 16value of x : 17value of x : 18value of x : 19 ​ Java 增强 for 循环 Java5 引入了一种主要用于数组的增强型 for 循环。 Java 增强 for 循环语法格式如下: 123for(声明语句 ： 表达式)&#123; // 代码语句&#125; 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名，或者是返回值为数组的方法。 12345678910111213141516public class Test &#123; public static void main(String args[])&#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers )&#123; System.out.print( x ); System.out.print(","); &#125; System.out.print("\n"); String [] names =&#123;"James", "Larry", "Tom", "Lacy"&#125;; for( String name : names ) &#123; System.out.print( name ); System.out.print(","); &#125; &#125;&#125; 编译运行结果如下: 1210,20,30,40,50,James,Larry,Tom,Lacy, 2.6.4 break 与 continue 语句跳转语句用于实现在执行过程中程序流程的跳转 1、break 关键字break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。 break 跳出最里层的循环，并且继续执行该循环下面的语句。 1234567891011121314public class Test &#123; public static void main(String args[]) &#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers ) &#123; // x 等于 30 时跳出循环 if( x == 30 ) &#123; break; &#125; System.out.print( x ); System.out.print("\n"); &#125; &#125;&#125; 121020 2、continue 关键字continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。 在 for 循环中，continue 语句使程序立即跳转到更新语句。 在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。 12345678910111213public class Test &#123; public static void main(String args[]) &#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers ) &#123; if( x == 30 ) &#123; continue; &#125; System.out.print( x ); System.out.print("\n"); &#125; &#125;&#125; 编译运行结果： 123410204050 2.6.5 循环嵌套循环嵌套是指在一条循环语句的循环体中再定义一条循环语句的语法结构。常见的有两层for循环 2.7 方法2.7.1那么什么是方法呢？Java方法是语句的集合，它们在一起执行一个功能。 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用 定义一个方法的语法格式： 123456修饰符 返回值类型 方法名 ([参数类型 参数名1，参数类型 参数名2，...])&#123; ... 方法体 ... return 返回值;&#125; 方法包含一个方法头和一个方法体。下面是一个方法的所有部分： 修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型,对访问权限进行限定。 返回值类型 ：方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。 方法名：是方法的实际名称。方法名和参数表共同构成方法签名。 参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。 方法体：方法体包含具体的语句，定义该方法的功能。 注意： 在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。 2.7.2 方法的重载方法重载就是在一个程序中可以定义多个同名方法，但要求每个方法具有不同的参数类型或参数个数。 12345678910111213141516171819202122232425package com.it2m.example;public class Examplell&#123; public static void main(String[] args)&#123; //下面是针对求和方法的调用 int sum1 = add(2,3); int sum2 = add(2,3,4); double sum3 = add(2.5,2.5); //打印求和结果 System.out.println("sum1="+sum1); System.out.println("sum2="+sum2); System.out.println("sum3="+sum3); &#125; //实现两个整数相加的方法 public static int add(int x, int y)&#123; return x+y; &#125; //实现三个整数相加的方法 public static int add(int x, int y, int z)&#123; return x+y+z; &#125; //实现两个小数相加的方法 public static double add(double x, double y)&#123; return x+y; &#125;&#125; 上述代码定义了三个同名的add( )方法，但它们的参数个数或类型不同，从而构成了方法的重载。 2.8 数组2.8.1 数组的定义数组是指一组数据的集合，数组中的每个数据被称为元素。数组可以存放任意类型的元素，但同一个数组中存放的元素类型必须一致。 Java 中定义一个数组的格式： 1int x = new int[10]; 或 12int[] x;x = new int[10] 上述语句定义了一个 int 类型的数组，[ ]中的数字10表示数组的长度，即可以存放10个元素，相当于在内存中定义了10个int类型的变量。 每个数组元素都有一个索引，通过这个索引可以访问数组中的元素，索引范围[0, array.length-1]。 下面的图片描绘了数组 myList。这里 myList 数组里有 10 个 double 元素，它的下标从 0 到 9。 2.8.2 数组的常见操作1、 数组遍历数组的遍历指依次访问数组中的每个元素，可以用for循环遍历或foreach循环。 12345678910111213public class TestArray&#123; public static void main(String[] args)&#123; int[] mylist = &#123;3, 2, 1, 5, 6&#125;; //for 循环遍历数组元素 for(int i = 0; i &lt; mylist.length; i++)&#123; System.out.println(arr[i]); &#125; //foreach循环遍历数组 for(int element: mylist)&#123; System.out.println(element); &#125; &#125;&#125; 2.数组的最值12345678910public static int getMax(int[] arr)&#123; int max = arr[0]; //定义变量max用于记住最大元素，首先假设第一个元素为最大值 //下面遍历数组元素 for(int x=1; x&lt;arr.length; x++)&#123; if(arr[x] &gt; max)&#123; max = arr[x]; &#125; &#125; return max;&#125; 3. 数组排序即让数组元素从小到大排序。后续数据结构与算法再了解。 2.8.3 Arrays 工具类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。 具有以下功能： 给数组赋值：通过 fill 方法。 对数组排序：通过 sort 方法,按升序。 比较数组：通过 equals 方法比较数组中元素值是否相等。 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。 | 序号 | 方法和说明 || —— | —————————————————————————————— || 1 | public static int binarySearch(Object[] a, Object key)用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。 || 2 | public static boolean equals(long[] a, long[] a2)如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 || 3 | public static void fill(int[] a, int val)将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 || 4 | public static void sort(Object[] a)对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 | 2.9 String 类和 StringBuffer 类所谓的字符串就是一连串的字符，它由许多单个字符连接而成。字符串广泛应用 在Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类和 StringBuffer类来创建和操作字符串。String 类和 StringBuffer 类都位于java.lang包中，因此不需要导包就可以直接使用。 2.9.1 String 类String 类是不可改变的，所以一旦创建了 String 对象，那它的值就无法改变了 1. 创建字符串 (1)使用字符串常量直接初始化一个String对象 1String str1 = "abc"； (2)使用String 的构造方法初始化String对象 1234String str2 = new String(); //初始化一个空的字符串char[] helloArray = &#123;'h', 'e', 'l', 'l', 'o'&#125;;String str3 = new String(helloArray);string str4 = new String("abc"); //根据指定字符串内容初始化 2. String 类的常用方法1 char charAt(int index)返回指定索引处的 char 值。2 int compareTo(Object o)把这个字符串和另一个对象比较。3 int compareTo(String anotherString)按字典顺序比较两个字符串。4 int compareToIgnoreCase(String str)按字典顺序比较两个字符串，不考虑大小写。5 String concat(String str)将指定字符串连接到此字符串的结尾。6 boolean contentEquals(StringBuffer sb)当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。7 static String copyValueOf(char[] data)返回指定数组中表示该字符序列的 String。8 static String copyValueOf(char[] data, int offset, int count)返回指定数组中表示该字符序列的 String。9 boolean endsWith(String suffix)测试此字符串是否以指定的后缀结束。10 boolean equals(Object anObject)将此字符串与指定的对象比较。11 boolean equalsIgnoreCase(String anotherString)将此 String 与另一个 String 比较，不考虑大小写。12 byte[] getBytes() 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。13 byte[] getBytes(String charsetName)使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。14 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)将字符从此字符串复制到目标字符数组。15 int hashCode()返回此字符串的哈希码。16 int indexOf(int ch)返回指定字符在此字符串中第一次出现处的索引。17 int indexOf(int ch, int fromIndex)返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。18 int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。19 int indexOf(String str, int fromIndex)返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。20 String intern() 返回字符串对象的规范化表示形式。21 int lastIndexOf(int ch) 返回指定字符在此字符串中最后一次出现处的索引。22 int lastIndexOf(int ch, int fromIndex)返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。23 int lastIndexOf(String str)返回指定子字符串在此字符串中最右边出现处的索引。24 int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。25 int length()返回此字符串的长度。26 boolean matches(String regex)告知此字符串是否匹配给定的正则表达式。27 boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)测试两个字符串区域是否相等。28 boolean regionMatches(int toffset, String other, int ooffset, int len)测试两个字符串区域是否相等。29 String replace(char oldChar, char newChar)返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。30 String replaceAll(String regex, String replacement)使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。31 String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。32 String[] split(String regex)根据给定正则表达式的匹配拆分此字符串。33 String[] split(String regex, int limit)根据匹配给定的正则表达式来拆分此字符串。34 boolean startsWith(String prefix)测试此字符串是否以指定的前缀开始。35 boolean startsWith(String prefix, int toffset)测试此字符串从指定索引开始的子字符串是否以指定前缀开始。36 CharSequence subSequence(int beginIndex, int endIndex) 返回一个新的字符序列，它是此序列的一个子序列。37 String substring(int beginIndex)返回一个新的字符串，它是此字符串的一个子字符串。38 String substring(int beginIndex, int endIndex)返回一个新字符串，它是此字符串的一个子字符串。39 char[] toCharArray()将此字符串转换为一个新的字符数组。40 String toLowerCase()使用默认语言环境的规则将此 String 中的所有字符都转换为小写。41 String toLowerCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。42 String toString() 返回此对象本身（它已经是一个字符串！）。43 String toUpperCase()使用默认语言环境的规则将此 String 中的所有字符都转换为大写。44 String toUpperCase(Locale locale)使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。45 String trim()返回字符串的副本，忽略前导空白和尾部空白。46 static String valueOf(primitive data type x)返回给定data type类型x参数的字符串表示形式。 记不住没关系，查相关API 文档或百度谷歌就好了。 2.9.2 StringBuffer 类String字符串是常量，一旦创建，其内容和长度不可改变。 当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。 StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 StringBuffer 方法以下是 StringBuffer 类支持的主要方法： 序号 方法描述 1 public StringBuffer append(String s)将指定的字符串追加到此字符序列。 2 public StringBuffer reverse() 将此字符序列用其反转形式取代。 3 public delete(int start, int end)移除此序列的子字符串中的字符。 4 public insert(int offset, int i)将 int 参数的字符串表示形式插入此序列中。 5 replace(int start, int end, String str)使用给定 String 中的字符替换此序列的子字符串中的字符。 2.10 包装类在Java 中，很多类的方法都需要接收引用类型的对象，此时就无法将一个基本数据类型的值传入。 JDK中提供了一系列的包装类，通过这些包装类可以将基本数据类型的值包装为引用数据类型的对象。 ​ 8种基本数据类型及其对应的包装类 基本数据类型 对应的包装类 基本的数据类型 对应的包装类 char Character long Long byte Byte float Float int Integer double Double short Short boolean Boolean 包装类和基本数据类型在进行转换时，引入了装箱和拆箱的概念。 装箱： 指将基本数据类型的值转换为引用数据类型。 拆箱： 指将引用数据类型的对象转换为基本数据类型。 1234567public class Example&#123; public static void main(String args[])&#123; Integer a = 3; //自动装箱 int b = a + 4; //自动拆箱 System.out.println(b); &#125;&#125; 3. 面向对象哇哇哇，今天又被抖音，游戏，小说占据大半时间，早上7点半的闹钟又没成功，又在宿舍宅一天，论文又没动笔。卸载抖音，卸载追书神器，卸载王者荣耀，先打把。。。我的意志力自制力好薄弱。。。。。。没学完之前不下载，下载也不安装。。。。 Java 是 一种面向对象的编程语言。我自学的第一门语言是Python,C++学了基础语法部分，为了找工作，决定系统的学习Java,虽然系统学习进度有点慢，且见效慢，但可避免今后学习工作中老是感觉没系统学过，要不要从头学习。 03 面向对象3.1 面向对象的概念和特征面向对象的特征主要可以概括为封装性，继承性和多态性。 以下主要复制粘贴菜鸟教程上的，但我都看了一遍,因为不是亲手打的，所以没有灵魂。。。 1.封装性封装是面向对象的核心思想，是指将对象的属性和行为封装起来，不需要让外界知道内部是如何实现细节的。 封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。 封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 要访问该类的代码和数据，必须通过严格的接口控制。 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。 封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 实现Java封装的步骤 修改属性的可见性来限制对属性的访问（一般限制为private），例如： 1234public class Person &#123; private String name; private int age;&#125; 这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如： 123456789101112131415161718192021public class Person&#123; private String name; // 将name属性私有化 private int age; // 将age属性私有化 //公有的getter 和 setter 方法 public int getAge()&#123; return age; &#125; public String getName()&#123; return name; &#125; public void setAge(int age)&#123; this.age = age; //this.age 访问的是成员变量 &#125; public void setName(String name)&#123; this.name = name; &#125;&#125; 采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。 2. 继承性继承性是描述类与类之间的关系，在已有类的基础上扩展出新的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 兔子和羊属于食草动物类，狮子和豹属于食肉动物类。 食草动物和食肉动物又是属于动物类。 所以继承需要符合的关系是：is-a，父类更通用，子类更具体。 虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。 类的继承格式 在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下： 12345class 父类 &#123;&#125; class 子类 extends 父类 &#123;&#125; 子类继承父类之后，就具有父类当中的属性和方法，子类就不会存在重复的代码，维护性也提高，代码也更加简洁，提高代码的复用性（复用性主要是可以多次使用，不用再多次写同样的代码） 需要注意的是 Java 不支持多继承，但支持多重继承。 继承的特性 子类拥有父类非private的属性，方法。 子类可以拥有自己的属性和方法，即子类可以对父类的方法进行重写 。在子类中重写的方法必须与父类被重写的方法具有相同的方法名，参数列表以及返回值类型。 子类可以用自己的方式实现父类的方法。 Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 继承关键字 继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 extends关键字 在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。 123456789101112public class Animal &#123; private String name; private int id; public Animal(String myName, String myid) &#123; //初始化属性值 &#125; public void eat() &#123; //吃东西方法的具体实现 &#125; public void sleep() &#123; //睡觉方法的具体实现 &#125; &#125; public class Penguin extends Animal&#123; &#125; implements关键字 使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 1234567891011public interface A &#123; public void eat(); public void sleep();&#125; public interface B &#123; public void show();&#125; public class C implements A,B &#123;&#125; super 与 this 关键字 当子类重写父类的方法后，子类对象将不能访问父类被重写的方法，super就解决了这个问题。 super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 super.成员变量 super.成员方法([参数1，参数2…]) super([参数1， 参数2…]) //访问构造方法 this关键字：指向自己的引用。 123456789101112131415161718192021222324class Animal &#123; void eat() &#123; System.out.println("animal : eat"); &#125;&#125; class Dog extends Animal &#123; void eat() &#123; System.out.println("dog : eat"); &#125; void eatTest() &#123; this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 &#125;&#125; public class Test &#123; public static void main(String[] args) &#123; Animal a = new Animal(); a.eat(); Dog d = new Dog(); d.eatTest(); &#125;&#125; 输出结果为： 123animal : eatdog : eatanimal : eat final关键字 final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写： 声明类： 1final class 类名 &#123;//类体&#125; 声明方法： 1修饰符(public/private/default/protected) final 返回值类型 方法名()&#123;//方法体&#125; 注:实例变量也可以被定义为 final，被定义为 final 的变量（会变成常量）不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final。 3. 多态性多态是同一个行为具有多个不同表现形式或形态的能力。 多态就是同一个接口，使用不同的实例而执行不同操作，如图所示： ​ 多态性是对象多种表现形式的体现。 现实中，比如我们按下 F1 键这个动作： 如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档； 如果当前在 Word 下弹出的就是 Word 帮助； 在 Windows 下弹出的就是 Windows 帮助和支持。 同一个事件发生在不同的对象上会产生不同的结果。 多态的优点 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态存在的三个必要条件 继承 重写 父类引用指向子类对象 比如： 1Parent p = new Child(); //将Child对象当作 Parent类型使用 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。 多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test &#123; public static void main(String[] args) &#123; show(new Cat()); // 以 Cat 对象调用 show 方法 show(new Dog()); // 以 Dog 对象调用 show 方法 Animal a = new Cat(); // 向上转型 a.eat(); // 调用的是 Cat 的 eat Cat c = (Cat)a; // 向下转型 c.work(); // 调用的是 Cat 的 work &#125; public static void show(Animal a) &#123; a.eat(); // 类型判断 if (a instanceof Cat) &#123; // 猫做的事情 Cat c = (Cat)a; c.work(); &#125; else if (a instanceof Dog) &#123; // 狗做的事情 Dog c = (Dog)a; c.work(); &#125; &#125; &#125; abstract class Animal &#123; abstract void eat(); &#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println("吃鱼"); &#125; public void work() &#123; System.out.println("抓老鼠"); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println("吃骨头"); &#125; public void work() &#123; System.out.println("看家"); &#125; &#125; 执行以上程序，输出结果为： 123456吃鱼抓老鼠吃骨头看家吃鱼抓老鼠 多态的实现方式 方式一：重写： Java 重写(Override)与重载(Overload)。 方式二：接口 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。 java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。 方式三：抽象类和抽象方法 3.2 类与对象3.2.1 类与对象的关系面向对象的编程思想是让code中对事物的描述和在现实中事物的形态相关联。 一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 ​ ​ 上图中男孩女孩为类，而具体的每个人为该类的对象 1. Java中的类类可以看成是创建Java对象的模板。 12345678910111213public class Dog&#123; String breed; int age; String color; void barking()&#123; &#125; void hungry()&#123; &#125; void sleeping()&#123; &#125;&#125; 一个类可以包含以下类型变量： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。 一个类可以拥有多个方法，在上面的例子中：barking()、hungry()和sleeping()都是Dog类的方法 构造方法 每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。 在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 下面是一个构造方法示例： 12345678public class Puppy&#123; public Puppy()&#123; &#125; public Puppy(String name)&#123; // 这个构造器仅有一个参数：name &#125;&#125; 2. Java中的对象所有对象都有自己的状态和行为。 拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。 对比现实对象和软件对象，它们之间十分相似。 软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。 在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。 创建对象 类名 对象名 = new 类名(); 对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步： 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 12345678910public class Puppy&#123; public Puppy(String name)&#123; //这个构造器仅有一个参数：name System.out.println("小狗的名字是 : " + name ); &#125; public static void main(String []args)&#123; // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( "tommy" ); &#125;&#125; 3.3 构造方法 (构造器)构造方法是类的一个特殊成员，它会在类实例化对象时被自动调用。定义构造方法，必须同时满足三个条件： 构造方法的名称与类名必须相同。 在方法名称前没有返回值类型的声明。 在方法体中不可以使用return语句返回一个值，但允许单独写return语句作为方法的结束。 子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。 如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。 1234567891011121314151617181920212223242526272829class SuperClass &#123; private int n; SuperClass()&#123; System.out.println("SuperClass()"); &#125; SuperClass(int n) &#123; System.out.println("SuperClass(int n)"); this.n = n; &#125;&#125;class SubClass extends SuperClass&#123; private int n; SubClass()&#123; super(300); System.out.println("SubClass"); &#125; public SubClass(int n)&#123; System.out.println("SubClass(int n):"+n); this.n = n; &#125;&#125;public class TestSuperSub&#123; public static void main (String args[])&#123; SubClass sc = new SubClass(); SubClass sc2 = new SubClass(200); &#125;&#125; 输出结果为： 1234SuperClass(int n)SubClassSuperClass()SubClass(int n):200 3.3.1 构造方法的重载由于构造方法的方法名与类名相同，因此只要每个构造方法的参数类型或参数个数不同即可实现构造方法的重载。 在创建实例对象时，根据传入参数的不同，分别调用不同的构造方法为不同属性进行赋值。 3.4 this 关键字一个类可以包含以下类型变量： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。 this 关键字表示当前对象，可以在方法中调用其他的成员。 通过this关键字可以明确地访问一个类的成员变量，解决与局部变量名称相同的问题。 123456789public class Car&#123; String color; // 类中定义的成员变量 color public Car(String color)&#123; //构造方法中参数被定义为color,是一个局部变量 this.color = color; //构造方法中使用this.color,访问成员变量 &#125; public int getColor()&#123; return this.color; //访问成员变量 &#125;&#125; 通过this关键字调用成员方法 1234567public class Car&#123; public void show()&#123; &#125; public void run()&#123; this.show(); //this 可省略 &#125;&#125; 构造方法在实例化对象时被JVM自动调用，在程序中不能像调用其他方法一样调用构造方法，但可以在一个构造方法中使用this([参数1， 参数2…])的形式调用其他构造方法。 123456789public class Car&#123; public Car()&#123; System.out.println("无参构造方法执行了..."); &#125; public Car(String color)&#123; this(); //调用无参构造方法 System.out.println("有参构造方法执行了...")； &#125;&#125; ​ 测试类： 12345public class TestCar&#123; public static void main(String[] args)&#123; Car c = new Car(&quot;red&quot;); //实例化Car对象 &#125;&#125; 先执行无参构造方法，之后再执行有参构造方法。 this 关键字调用其他的构造方法只能出现在构造方法中，只能位于构造方法的第一行且只能出现一次。另外，不能再两个构造方法中使用this相互调用，否则会出现编译错误。 3.5 static 关键字3.5.1 静态变量如果使用一个类，则会在产生实例化对象时分别在堆内存中分配空间，在堆内存中要保存对象的属性，每个对象都有自己的属性，若希望被所有对象共享，就必须用static关键字修饰成员变量 ，该变量被称为静态变量 ，可以直接使用“类名.变量名”的形式调用。static不能修饰局部变量。 123public class Car&#123; static String carName="大众"; //定义了静态变量carName,表示汽车所在的厂商，并被所有的实例所共享。&#125; 12345678public class TestCar&#123; public static void main(String[] args)&#123; Car c1 = new Car(); Car.carName=&quot;大众&quot;; //为静态变量赋值 System.out.println(&quot;这辆车的厂商是：&quot;+Car.carName); System.out.println(&quot;这辆车的厂商是：&quot;+c1.carName); &#125;&#125; 输出结果均为大众。 3.5.2 静态方法静态方法与普通方法的区别是在方法前加一个static关键字，这种方法被称为静态方法，可以通过“类名.方法名”访问，也可以通过类的实例对象访问。静态方法在调用时不需要创建任何对象。 12345public class Car&#123; public static void run()&#123; //定义了静态方法run() System.out.println("run()方法执行了..."); &#125;&#125; 123456789public class TestCar&#123; public static void main(String[] args)&#123; //1. 类名.方法名的方式调用静态方法 Car.run(); //2. 实例化对象的方式调用静态方法 Car c = new Car(); c.run(); &#125;&#125; 3.5.3 静态代码块在Java类中，使用一对大括号包围起来的若干行代码被称为一个代码块，用static关键字修饰的代码块被称为静态代码块。当类被加载时，静态代码块就会被执行，由于类只能加载一次，所以静态代码块只会执行一次。在程序中，通常会使用静态代码块对类的成员变量进行初始化。 3.6 抽象类和接口3.6.1 抽象类在Java程序中，允许在定义方法时不写方法体，这种方法被称为抽象方法 ，必须用abstract 关键字修饰。抽象方法解决了程序中某些方法的不确定实现。 如果一个类中定义了抽象方法，则该类必须定义为抽象类，也同样使用abstract修饰。 包含抽象方法的类必须声明为抽象类，但抽象类可以不包括任何抽象方法。 抽象类不可以被实例化，因为抽象方法时没有方法体的，不可以被调用。如果想调用抽象类中定义的方法，则需要创建一个子类，在子类中将抽象类中的抽象方法进行实现。 1234//定义抽象类Animalpublic abstract class Animal&#123; abstract void call; //定义抽象方法call()&#125; 123456public class Cow extends Animal&#123; //实现抽象方法call() void call()&#123; System.out.println("哞..."); &#125;&#125; 3.6.2 接口一种特殊的抽象类，该类中只存在常量和抽象方法，而不存在变量的定义和方法的实现，这种特殊的类被称为接口。是对抽象类的进一步抽象。定义接口时，需要使用interface关键字，由于方法都是抽象的，不能实例化对象，所以需要定义一个类，并使用implements关键字实现接口中所有的方法。 创建一个Animal接口，并在接口中定义一个全局常量和抽象方法： 123456//定义Aniamal接口interface Animal&#123; //全局变量，默认修饰为 public static final，不需要指定 String ANIMAL_ACTION = "动物的行为动作"; void call(); //抽象方法call(),默认修饰为public abstract&#125; 创建一个Cow类，是其实现Animal接口，并实现接口中的抽象方法call(): 123456class Cow implements Animals&#123; //实现call()方法 public void call()&#123; System.out.println(ANIMAL_ACTION+":"+"哞..."); &#125;&#125; 注意，一个类实现一个接口时，必须实现接口在所有的方法，若不能实现，则必须写出一个空实现的方法。 接口的访问限定只有public和默认，允许接口的多重继承。 3.6.3 匿名内部类方法的参数被定义成为一个接口类型，除了定义一个类实现接口，将类进行对象实例化外，还可以使用匿名内部类实现接口。 在定义匿名内部类的地方往往直接创建该类的一个对象。 123new 父类（参数列表）或 父接口()&#123; //匿名内部类实现部分&#125; 1234//定义动物类接口interface Animal&#123; void call(); //定义方法call()&#125; 测试类 123456789101112131415public calss TestAnimal&#123; public static void main(String[] args)&#123; //定义匿名内部类作为参数传递给animalCall()方法 animalCall(new Animal()&#123; //实现call()方法 public void call()&#123; System.out.println("哞..."); &#125; &#125;); &#125; //定义静态方法animalCall() public static void animalCall(Animal a)&#123; a.call(); //调用传入对象a的call()方法 &#125;&#125; 调用animalCall()方法时，在方法的参数位置写上new Animal(){},这相当于创建了一个实例对象，并将对象作为参数传递给animalCall()方法。 3.7 异常程序运行过程中，可能会发生异常(Exception)情况，例如运行时内存溢出，磁盘空间不足、网络中断等，针对此类情况，Java 提供了异常处理机制，以异常类的形式对这些不正常的情况进行封装，通过异常处理机制对程序代码发生的各种问题进行有针对性的处理。 原因： 用户输入了非法数据。 要打开的文件不存在。 网络通信时连接中断，或者JVM内存溢出。 3.7.1 常见的异常类所有的异常类是从 java.lang.Exception 类继承的子类。 Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。 Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。 Error 用来指示运行时环境发生的错误。表示系统内部错误或资源耗尽的错误。 例如，JVM 内存溢出。一般地，程序不会从错误中恢复。 异常类有两个主要的子类：IOException 类和 RuntimeException 类。 3.7.2 捕获异常1. try …catch使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。 try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下： 1234567try&#123; // 程序代码&#125;catch(ExceptionName e1)&#123; //Catch 块&#125; Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。 如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。 2. finally关键字finally 关键字用来创建在 try 代码块后面执行的代码块。 无论是否发生异常，finally 代码块中的代码总会被执行。 在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。 finally 代码块出现在 catch 代码块最后，语法如下： 123456789try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;finally&#123; // 程序代码&#125; 3.7.3 throws/throw 关键字： 抛出异常如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。 也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。 下面方法的声明抛出一个 RemoteException 异常： 12345678910import java.io.*;public class className&#123; public void withdraw(double amount) throws RemoteException, InsufficientFundsException &#123; // Method implementation &#125; //Remainder of class definition&#125; 3.8 访问控制访问控制级别由大到小。 修饰符 当前类 同一包内 子孙类(同一包) 子孙类(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y/N（说明） N default Y Y Y N N private Y N N N N public(公共访问级别)：表示公有的，该类或类中的成员都可以被所有的类访问。使用对象：类、接口、变量、方法。 protected(子类访问级别)：表示受保护的，对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private(类访问级别) : 表示私有的，在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） 04 集合4.1 集合类方便对多个对象进行存取操作。 为了保存数目不确定的对象，JDK中提供了集合类（又称容器类），这些类可以存储任意类型的对象，并且长度可变，所有集合类都位于java.util包中，使用时需要导入该包，否则会出现异常。 从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。 集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容： 接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。 除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。 Collection: 单列集合类的根接口 List和Set 接口继承自Collection接口，习惯将List接口的对象称为List集合。List集合元素有序且可重复，Set集合无序不重复。 ArrayList 是List接口的一个实现类，在ArrayList内部封装了一个长度可变的数组，当存入的元素超过数组长度时，ArrayList会在内存中分配一个更大的数组存储这些元素，因此可将ArrayList集合看作一个长度可变的数组 Iterator 接口 主要用于遍历Collection和其子类中的元素，因此Iterator对象也被称为迭代器。 Map接口： 双列集合，集合中的每个元素都包含一个键对象Key和一个值对象Value,键和值是一一对应的关系，称为映射。 HashMap集合：基于哈希表的Map接口的实现，用于存储键值映射关系，但不保证映射的顺序。 Properties集合： 主要用于存储字符串类型的键和值。 集合接口 集合框架定义了一些接口。本节提供了每个接口的概述： 序号 接口描述 1 Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。Collection 接口存储一组不唯一，无序的对象。 2 List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象。 3 Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。Set 接口存储一组唯一，无序的对象。 4 SortedSet 继承于Set保存有序的集合。 5 Map 接口存储一组键值对象，提供key（键）到value（值）的映射。 6 Map.Entry 描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。 7 SortedMap继承于 Map，使 Key 保持在升序排列。 8 Enumeration这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。 Set和List的区别 Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。 Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;。 List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。 4.2 泛型Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？ 答案是可以使用 Java 泛型。 使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。 5.1 输入/输出（I/O)是指程序与外部设备或者计算机之间的交互操作，如从键盘输入数据，在显示器显示数据等。 在Java中，将这种不同输入/输出设备（键盘、内存、网络、显示器）之间的数据传输抽象为“流”,Stream 一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。由于Java中的流都位于java.io包中，因此称为I/O流。按照操作数据的不同，分为字节流和字符流，按数据传输方式的不同又分为输入流Reader和输出流Writer。 05 读写5.2 字节流字节流是指针对字节输入/输出提供的一系列流，JDK中提供了两个抽象类InputStream和OutputStream表示字节输入流和字节输出流，它们是字节流的两个顶级父类。 5.2.1 字节流的读/写操作计算机的数据基本都保存在硬盘的文件中，在操作文件时，最常见的就是从文件中读取数据并将数据写入文件，即文件的读/写。针对文件的读/写,JDK专门提供了两个类，分别是FileInputStream和FileOutputStream. 在src目录下创建一个文本文件itheima.txt，在文件输入内容“Hello”并保存，然后创建一个读取文件文本文件的类。 12345678910111213141516import java.io.*;public class Example01&#123; public static void main(String[] args) throws Exception&#123; //创建一个字节输入流 FileInputStream input = new FileInputStream("itheima.txt"); int i = 0; //定义一个int类型的变量i,记住每次读取的一个字节 while(true)&#123; i = input.read(); // 变量i记住读取的一个字节 if(i==-1)&#123; break; //如果读取的字节为-1，跳出while循环 &#125; System.out.println(i); //否则将i写出 &#125; input.close(); //关闭资源 &#125;&#125; 通常情况下读取文件输出结果为字符，输出数字是因为在硬盘上存储的文件都是以字节的形式存在的，上述代码结果是五个字节所对应的十进制数。 12345678910111213import java.io.*;public class Example02&#123; public static void main(String[] args) throws Exception&#123; //创建一个文件字节输出流 FileOutputStream output = new FileOutputStream("test.txt"); String s = "www.baidu.com"; //定义一个String类型字符串 byte[] arr = s.getBytes(); //将字符串变成字节数组 for(int i=0; i&lt;arr.length;i++)&#123; output.write(arr[i]); //将数组中的数据写入到目标文件中 &#125; output.close(); //关闭资源 &#125;&#125; 通过FileOutputStream写数据时，自动创建了文件test.txt,并将数据写入文件，若是向一个已经存在的文件中写入数据，则文件中数据首先被清空，再写入新的数据。 若遇到I/O异常，close()方法将无法执行，流对象所占用的系统资源将无法释放，为了保证I/O流的close()方法必须执行，通常将关闭流的操作写在finally代码块中。 123456789101112131415161718import java.io.*;public static void main(String[] args)&#123; FileOutputStream output = null; //创建一个文件字节输出流 try&#123; output = new FileOutputStream("test.txt"); String s = "www.baidu.com"; byte[] arr = s.getBytes(); for(int i = 0 ; i &lt; arr.length; i++)&#123; output.write(arr[i]); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finally&#123; if(output != null)&#123; output.close(); &#125; &#125;&#125; 5.2.2 字节流的缓冲区提高效率，定义一个字节数组作为缓冲区，将读取到的单个字节保存到字节数组中，然后将字节数组中的数据一次性写入文件。右击项目选择New-Folder,创建文件夹source和target，在source文件夹中存放一jpg图片，将图片复制到target文件夹中。 1234567891011121314151617181920import java.io.*;public class Example03&#123; public static void main(String[] args) throws Exception&#123; //创建一个字节输入流，用于读取当前目录下source文件夹中的图片 FileInputStream input = new FileInputStream("source\picturename.jpg"); //创建一个文件字节输出流，用于将读取到的数据写入target文件目录下的图片 FileOutputStream output = new FileOutputStream("target\picturename.jpg"); byte[] buffer = new byte[1024]; //定义一个字节数组作为缓冲区 int length; //定义变量length记住读取缓冲区的字节数 long startTime = System.currentTimeMills(); //获取复制图片前的系统时间 while((length=input.read(buffer)) != -1)&#123; //判断是否读到文件末尾 //从第一个字节开始，向文件写入length个字节 output.write(buffer,0,length); &#125; long endTime = System.currentTimeMills(); System.out.println("复制图片所消耗的时间为："+(endTime-startTime)+"毫秒"); input.colse(); output.close(); &#125;&#125; 5.2.3 字节缓冲流在进行文件复制时，使用字节流缓冲区可以提高程序的效率，此外，还可以使用java.io包中自带缓冲功能的字节缓冲流，分别是BufferedInputStream和BufferedOutputStream,这两个流在实例化时需要接收InputStream和OutputStream类型的对象作为参数。 1234567891011121314151617181920import java.io.*;public class Example04&#123; public static void main(String[] args) throws Exception&#123; //创建一个带缓冲区的输入流 BufferedInputStream bufferInput = new BufferedInputStream( new FileInputStream("source\picturename.jpg")); //创建一个带缓冲区的输出流 BufferedOutputStream bufferOutput = new BufferedOutputStream( new FileOutputStream("target\picturename.jpg")); long startTime = System.currentTimeMills(); int length; while((length = bufferInput.read()) != -1)&#123; bufferOutput.write(length); &#125; long endTime = System.currentTimeMills(); System.out.println("复制图片所消耗的时间为："+(endTime-startTime)+"毫秒"); bufferInput.close(); bufferOutput.close(); &#125;&#125; 5.3 字符流字符流的目标通常是文本文件，Reader和Writer是java.io包中所有字符流的抽象父类，定义了在I/O流中读/写字符数据的通用API,在Java中，字符采用的是Unicode字符编码 5.3.1 字符流的读/写操作在项目下创建文本文件”read.txt”,并在其中输入字符”www.baidu.com”,然后创建一个字符输入流FileReader读取文本文件中的内容 123456789101112import java.io.*;public class Example05&#123; public static void main(String[] args) throws Exception&#123; //创建一个FileReader对象用于读取文件中的字符 FileReader fileReader = new FileReader("read.txt"); int i; //定义一个变量用于记录读取的字符 while((i=fileReader.read()) != -1)&#123; //循环判断是否读取到文件的末尾 System.put.print((char) i); //不是字符流末尾就转为字符打印 &#125; fileReader.close(); &#125;&#125; 12345678910import java.io.*;public class Example06&#123; public static void main(String[] args) throws Exception&#123; //创建一个FileWriter对象用于向文件中写入数据 FileWriter fileWriter = new FileWriter("write.txt"); String s = "你好，www.baidu.com"; fileWriter.write(s); //将字符数据写入到文本文件中 fileWriter.close(); //关闭写入流，释放资源 &#125;&#125; 程序运行后，会在当前目录下生成write.txt文件 5.3.2 字符缓冲流BufferedReader用于对字符输入流提供缓冲区，BufferedWriter用于对字符输出流提供缓冲区。 BufferedReader中readLine()方法用于一次读取一行文本。 123456789101112131415161718import java.io.*;public class Example07&#123; public static void main(String[] args) throws Exception&#123; //创建一个BufferedReader缓冲对象 BufferedReader bufferReader = new BufferedReader(new FileReader("read.txt")); //创建一个BufferedWriter缓冲区对象 BufferdWriter bufferWriter = new BufferedWriter(new FileWriter("dest.txt")); String s = null; //每次读取一行文本，判断是否到文件末尾 while((s=bufferReader.readLine()) != null)&#123; bufferWriter.write(s); //写入一个换行符，该方法会根据不同的操作系统生成相应的换行符 bufferWriter.newLine(); &#125; bufferReader.close(); bufferWriter.close(); &#125;&#125; 5.3.3 转换流OutputStreamWriter,能将一个字节输出流转换为字符输出流，方便直接写入字符 InputStreamReader,能将一个字节输入流转换为字符输入流，方便直接读写字符 123456789101112131415161718192021222324import java.io.*;public class Example08&#123; public static void main(String[] args) throws Exception&#123; //创建字节输入流 FileInputStream input = new FileInputStream("read.txt"); //将字节输入流转换为字符输入流 InputStreamReader streamReader = new InputStreamReader(input); //赋予字符输入流对象缓冲区 BufferedReader bufferReader = new BufferedReader(streamReader); //创建字节输出流 FileOutputStream output = new FileOutputStream("dest2.txt"); //将字节输出流转换为字符输出流 OutputStreamWriter streamWriter = new OutputStreamWriter(output); //赋予字符输出流对象缓冲区 BufferedWriter bufferWriter = new BufferedWriter(streamWriter); String line = null; //判断是否读到文件末尾 while((line=bufferReader.readLine()) != null)&#123; bufferWriter.write(line); //输出读取到的文件 &#125; bufferReader.close(); bufferWriter.close(); &#125;&#125; 06 多线程6.1 多线程进程：在一个操作系统中，每个独立执行的程序都可称为一个进程(正在运行的程序)。 CPU具备分时机制，每个时间点只能执行一个程序，由于CPU运行速度非常快，所以能够在极短时间内在不同的进程之间进行切换。 线程： 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 当一个Java程序启动时，就会产生一个进程，该进程会默认创建一个线程，称为主线程，在主线程上会运行main()方法中的代码。 一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。 6.1.1 一个线程的生命周期线程是一个动态执行的过程，它也有一个从产生到死亡的过程。 下图显示了一个线程完整的生命周期。 新建状态: 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态: 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态: 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态: 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态: 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 6.1.2 线程的优先级每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。 Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 6.2.1 创建一个线程Java 提供了三种创建线程的方法： 通过实现 Runnable 接口； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程。 6.2.2通过继承Thread来创建线程创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。 继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。 该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。 创建ThreadDemo类，继承于Thread类，并重写Thread类的run()方法，在run()方法中通过for循环输出5次” ThreadDemo类的run()方法执行了” 1234567public class ThreadDemo extends Thread&#123; public void run()&#123; for(int i = 0; i &lt; 5; i++)&#123; System.out.println("ThreadDemo类的run()方法执行了"); &#125; &#125; &#125; 创建测试类，在该类中创建一个线程对象threadDemo，并调用start()方法启动子线程，然后通过for循环在main()方法(主线程)中输出五次”主方法main()执行了“。 123456789public class TestThread&#123; public static void main(String[] args)&#123; ThreadDemo threadDemo = new ThreadDemo(); //创建线程ThreadDemo的线程对象 threadDemo.start(); //开启线程 for(int i = 0; i &lt; 5; i++)&#123; System.out.println("主方法main()执行了"); &#125; &#125;&#125; 运行结果： 12345678910主方法main()执行了主方法main()执行了主方法main()执行了ThreadDemo类的run()方法执行了ThreadDemo类的run()方法执行了ThreadDemo类的run()方法执行了ThreadDemo类的run()方法执行了ThreadDemo类的run()方法执行了主方法main()执行了主方法main()执行了 两个for循环输出语句交错执行，该程序实现了多线程。 6.2.3 通过实现 Runnable 接口来创建线程创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。 为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下： 1public void run() 在创建一个实现 Runnable 接口的类之后，可以在类中实例化一个线程对象。 Thread 定义了几个构造方法，下面的这个是经常使用的： 1Thread(Runnable threadOb,String threadName); 这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。 新线程创建之后，调用它的 start() 方法它才会运行。’’ 1void start(); 1234567891011121314151617181920212223242526272829303132333435363738394041class RunnableDemo implements Runnable&#123; private Thread t; private String threadName; RunnableDemo(String name)&#123; threadName = name; System.out.println("Creating " + threadName); &#125; public void run()&#123; System.out.println("Running " + threadName); try&#123; for(int i = 4; i&gt;0; i--)&#123; System.out.println("Thread: " + threadName + ", " + i); //让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch(InterruptedException e)&#123; System.out.println("Thread " + threadName + "interrupted."); &#125; System.out.println("Thread " + threadName + "exiting."); &#125; public void start()&#123; System.out.println("Starting" + threadName); if(t == null)&#123; t = new Thread(this,threadName); t.start(); &#125; &#125;&#125;public class TestThread&#123; public static void main(String[] args)&#123; RunnableDemo R1 = new RunnableDemo("Thread-1"); R1.start(); RunnableDemo R2 = new RunnableDemo("Thread-2"); R2.start(); &#125;&#125; 12345678910111213141516Creating Thread-1Starting Thread-1Creating Thread-2Starting Thread-2Running Thread-1Thread: Thread-1, 4Running Thread-2Thread: Thread-2, 4Thread: Thread-1, 3Thread: Thread-2, 3Thread: Thread-1, 2Thread: Thread-2, 2Thread: Thread-1, 1Thread: Thread-2, 1Thread Thread-1 exiting.Thread Thread-2 exiting. 6.3.1 同步代码块同步是指多个操作系统在同一个时间段内只能有一个线程进行，其他线程要等待此线程完成之后才可以继续执行，Java为同步操作提供了synchronized关键字。 123synchronized(同步对象)&#123; //需要同步的代码&#125; 在使用同步代码块时必须指定一个需要同步的对象，也称为锁对象，一般情况下都将当前对象this设置为同步对象。 被synchronized修饰的方法在某一时刻只允许一个线程访问，访问该方法的其他线程都会发生堵塞，直到当前线程访问完毕后，其他线程才有机会执行该方法。 123权限修饰符 synchronized 返回值类型 方法名([参数1,...])&#123; //需要同步的代码块&#125; 07 web7.1 HTMLHyper Text Markup Language ，超文本标记语言，主要作用是通过HTML标记对网页中的文本、图片、声音等内容进行描述。 HTML网页就是一个文件名后缀为.htm或.html的文件。可以用记事本打开、编写。 基本的HTML文档结构： 123456789&lt;! DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 带有&lt;&gt;符号的元素被称为HTML标记，标记是放在标记符(&lt;&gt;)中的用于表示某个功能的编码命令，也称为HTML标签或HTML元素。 &lt;! DOCTYPE HTML&gt;标记 该标记位于文档最前面，用于向浏览器说明当前文档使用的是那种HTML标准规范。 &lt; html &gt; 标记 根标记，用于告知浏览器其自身是一个HTML文档。 之间的内容是文档的头部和主体。 &lt; head &gt; 标记 头部标记，用于定义HTML文档的头部信息，封装其他位于文档头部的标记,例如： &lt; title &gt; 标记用于描述文档的标题 &lt; meta &gt; 标记可提供有关页面的元信息，也可指定字符编码 &lt; link &gt;标记用于定义文档与外部资源的关系，其最常见的用途是链接样式表 &lt; style &gt; 标记用于为HTML文档定义样式信息。 一个HTML文档只能含有一对&lt; head &gt; 标记，并且绝大多数文档头部包含的数据都不会真正作为内容显示在页面中。 &lt; body &gt; 标记 主体标记，用于定义HTML文档所要显示的内容，最终展示给用户的信息。与&lt; head &gt; 标记是并列关系。 7.1.1 单标记与双标记单标记也称空标记，是指用一个标记符号即可完整描述某个功能的标记。标记名与/之间有个空格： 12&lt;标记名 /&gt;&lt;hr /&gt; //定义一条水平线 双标记也称体标记，是指由开始和结束两个标记符号组成的标记 1&lt;标记名&gt;内容&lt;/标记名&gt; 7.1.2 文本控制与文本样式标记 段落标记&lt; p &gt; &lt; /p &gt; 和换行标记&lt; br /&gt; 文本样式标记 &lt; font &gt; 标记用于控制网页中文本的样式，如字体、字号和字体颜色等。 12&lt;font 属性="属性值"&gt;文本内容&lt;/font&gt;&lt;font face="微软雅黑" size="5" color="blue"&gt;5号蓝色文本，字体是微软雅黑&lt;/font&gt; ​ 7.1.3 图像标记&lt; img/ &gt;,主要用于显示HTML页面中的图像： 1&lt;img src="图像 URL" /&gt; src属性用于指定图像文件的路径，可以是相对路径，也可以是绝对路径。width与height属性分别用于设置图像的宽度与高度，单位为像素，border属性用于设置图像的边框，border=”0”表示无边框。 7.1.4 表格标记用于在页面中创建表格 12345&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 创建表格的三对基本标记，缺一不可。用于定义一个表格，用于定义表格中的行，必须嵌套在标记中，用于定义表格中的单元格，也可称为表格中的列，必须嵌套在中。表示表格边框的宽度为1像素，一般不要规定，而是使用CSS添加边框样式和颜色。 7.1.5 表单标记表单就是在网页上用于输入信息的区域，其主要功能是收集用户信息，并将这些信息传递给后台服务器。例如，网站注册页面中的用户名和密码输入框、提交按钮等。 表单主要由表单域、表单控件和提示信息三部分构成。 表单域： 相当于一个容器，用于容纳所有的表单控件和提示信息。 表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框提交按钮等。 提示信息：一个表单中通常还需要包含一些说明性的文字，即表单控件前的文字说明，用于提示用户进行填写和操作。 1. 表单域在HTML中，&lt; form &gt; 标记用于定义一个表单域，即创建一个表单 123&lt;form action="url地址" method="提交方式" name="表单名称"&gt; 各种表单控件&lt;/form&gt; action属性用于指定表单提交地址，如action=”login.jsp”表示表单数据会提交到名为login.jsp的页面进行处理。 method属性用于设置表单数据的提交方式，其取值为GET(默认值)或POST. name属性用于设置表单的名称。 2. 表单控件1&lt;input type="控件类型" /&gt; type=”text” 文本输入框控件 type=”button” 按钮控件 type=”password” 密码输入框控件 type=”radio”,单选输入框控件 type=”checkbox” 复选框控件 代码注释： 1&lt;! --注释内容--&gt; 7.1.6 列表标记和超链接标记用于展示列表信息的标记被称为列表标记，分为无序列表和有序列表 1、无序列表指列表的各个列表之间没有顺序级别之分，通常是并列的列表 12345678&lt;ul&gt; &lt;li&gt;列表项 1&lt;/li&gt; &lt;li&gt;列表项 2&lt;/li&gt; &lt;li&gt;列表项 3&lt;/li&gt; . . .&lt;/ul&gt; type 常用的有三种，disc、square和circle 2、超链接标记 标记环绕需要被链接的对象即可。 1&lt;a href="跳转目标" target="目标窗口的弹出方式"&gt;文本或图像&lt;/a&gt; href属性用于指定链接指向的页面URL target取值为 _self 和 _blank, 意为在原窗口打开和在新窗口打开。 7.1.7 &lt; div &gt; 标记div是DIVision的缩写，”分割、区域“， &lt; div &gt; 标记就是一个区块容器标记，可以将网页分割为独立且不同的部分，以实现网页的规划和布局 7.2 CSSCascading Style Sheet，层叠样式表单 是一种用于(增强)控制网页样式并允许将样式信息与网页内容分离的标记性语言。主要用于设置HTML页面中的文本内容(字体、字号、对齐方式等)、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。 1选择器&#123;属性 1:属性值 1; 属性 2:属性值 2; 属性 3:属性值 3;&#125; 1div&#123;border:2px solid blue; width:300px; height:200px;&#125; div为选择器，表示CSS样式作用的HTML对象 7.2.1 CSS样式的引用方式1. 内嵌式将CSS代码集中写在HTML文档的 头部标记中，并用 标记定义,一般不建议使用 12345&lt;head&gt; &lt;style type="text/css"&gt; 选择器&#123;属性 1:属性值 1; 属性 2:属性值 2; 属性 3:属性值 3;&#125; &lt;/style&gt;&lt;/head&gt; 2. 链入式将所有的样式放在一个或多个以css为扩展名的外部样式表文件中，通过 标记将外部样式表文件链接到HTML文件中 123&lt;head&gt; &lt;link href="CSS文件的路径" type="text/css" rel="stylesheet" /&gt;&lt;/head&gt; rel:定义当前文档与被链接文档之间的关系，指定为stylesheet，表示被链接的文档是一个样式表文件。 type=”text/css” 表示链接的外部文件为CSS CSS:http://www.w3school.com.cn/css/index.asp 7.3 JavaScripthttp://www.w3school.com.cn/b.asp 7.3.1 DOMDocument Object Model(文档对象模型） HTML DOM 定义了访问和操作 HTML 文档的标准方法。 DOM 将 HTML 文档表达为树结构。 ​ 什么是 HTML DOM？ HTML DOM 是： HTML 的标准对象模型 HTML 的标准编程接口 W3C 标准 HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法。 换言之，HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素的标准。 怎么办，不想写那个破论文，心里好慌啊。。。。为什么人生非得做一些身不由己的无聊事情，归根到底是穷，穷！ 现在这样，以后工作说不定还要妥协，破局的关键是提升自身实力，通过互联网赚得第一桶金子，依靠资本，资源交换，唯有钱生钱才是王道！不要被渣渣虐打，也不要一直做渣渣，要加油，要做大牛，做渣渣的感觉实在太不爽了，没钱还被人挑，做大牛，有钱又不被人虐！ 在 HTML DOM 中，所有事物都是节点。DOM 是被视为节点树的 HTML。 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 注释是注释节点 7.3.2 节点父、子和同胞节点树中的节点彼此拥有层级关系。 父（parent）、子（child）和同胞（sibling）等术语用于描述这些关系。父节点拥有子节点。同级的子节点被称为同胞（兄弟或姐妹）。 在节点树中，顶端节点被称为根（root） 每个节点都有父节点、除了根（它没有父节点） 一个节点可拥有任意数量的子 同胞是拥有相同父节点的节点 节点的访问 在DOM中，HTML文档的各个节点被视为各种类型的Node对象 1父节点对象 = 子节点对象.parentNode; getElementById() 方法 getElementById() 方法返回带有指定 ID 的元素： 1document.getElementById(&quot;intro&quot;); getElementsByTagName() 方法 getElementsByTagName() 返回带有指定标签名的所有元素。 1node.getElementsByTagName(&quot;tagname&quot;); 7.4 JavaScripthttp://www.w3school.com.cn/b.asp JavaScript 是脚本语言,不需要编译，直接嵌入在HTML页面中，可以把静态的页面转变成支持用户交互并响应的动态页面。 在HTML文档中，引入JavaScript的方式主要有两种：一种是在HTML文档中直接嵌入JavaScript脚本，称为内嵌式；另一种是链接外部JavaScript脚本文件，称为外嵌式。 HTML 中的脚本必须位于 与 标签之间。 脚本可被放置在 HTML 页面的 和 部分中。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;JavaScript 能够直接写入 HTML 输出流中：&lt;/p&gt;&lt;script type="text/javascript"&gt;document.write("&lt;h1&gt;This is a heading&lt;/h1&gt;");document.write("&lt;p&gt;This is a paragraph.&lt;/p&gt;");&lt;/script&gt;&lt;p&gt;您只能在 HTML 输出流中使用 &lt;strong&gt;document.write&lt;/strong&gt;。如果您在文档已加载后使用它（比如在函数中），会覆盖整个文档。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 输出结果： JavaScript 能够直接写入 HTML 输出流中： This is a heading This is a paragraph. 您只能在 HTML 输出流中使用 document.write。 如果您在文档已加载后使用它（比如在函数中），会覆盖整个文档。 外链式 1&lt;script type="text/javascript" src="JS文件的路径"&gt;&lt;/script&gt; 7.4.1 JS变量由于JavaScript是一种弱类型语言，所以在声明变量时，不需要指定变量的类型，使用var命令声明变量 123var number = 27;var str = "JavaScript";var x = 2; 变量必须以字母开头 变量也能以 $ 和 _ 符号开头（不过不推荐这么做） 变量名称对大小写敏感（y 和 Y 是不同的变量） 7.4.2 JS数据类型字符串、数字、布尔、数组、对象、Null、Undefined 1. JavaScript 拥有动态类型JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型： 123var x // x 为 undefinedvar x = 6; // x 为数字var x = "Bill"; // x 为字符串 2. JavaScript 字符串字符串是存储字符（比如 “Bill Gates”）的变量。 字符串可以是引号中的任意文本。可以使用单引号或双引号： 12var carname="Bill Gates";var carname='Bill Gates'; 3. JavaScript 数字JavaScript 只有一种数字类型。数字可以带小数点，也可以不带： 12var x1=34.00; //使用小数点来写var x2=34; //不使用小数点来写 极大或极小的数字可以通过科学（指数）计数法来书写： 12var y=123e5; // 12300000var z=123e-5; // 0.00123 4. JavaScript 布尔布尔（逻辑）只能有两个值：true 或 false。 12var x=truevar y=false 5. JavaScript 数组下面的代码创建名为 cars 的数组： 1234var cars=new Array();cars[0]="Audi";cars[1]="BMW";cars[2]="Volvo"; 或者 (condensed array): 1var cars=new Array("Audi","BMW","Volvo"); 或者 (literal array): 1var cars=["Audi","BMW","Volvo"]; 6. Undefined 和 NullUndefined 这个值表示变量不含有值。 可以通过将变量的值设置为 null 来清空变量。 12cars=null;person=null; 7. JavaScript 对象对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔： 1var person=&#123;firstname:&quot;Bill&quot;, lastname:&quot;Gates&quot;, id:5566&#125;; 上面例子中的对象 (person) 有三个属性：firstname、lastname 以及 id。 空格和折行无关紧要。声明可横跨多行： 12345var person=&#123;firstname : &quot;Bill&quot;,lastname : &quot;Gates&quot;,id : 5566&#125;; 对象属性有两种寻址方式： 12name=person.lastname;name=person[&quot;lastname&quot;]; 声明变量类型 当声明新变量时，可以使用关键词 “new” 来声明其类型： 12345var carname=new String;var x= new Number;var y= new Boolean;var cars= new Array;var person= new Object; JavaScript 变量均为对象。当声明一个变量时，就创建了一个新的对象。 7.4.3 运算符和Java的差不多 7.4.4 函数函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。 函数就是包裹在花括号中的代码块，前面使用了关键词 function： 1234function functionname()&#123;这里是要执行的代码&#125; 先学个大概，等需要的时候再搞，JS语言很简单的。 8.1 Java web8.1.1 C/S 与 B/S 架构 C/S (Client/Server) C/S 架构是一种典型的两层架构，其全称是Client/Server，即客户端服务器端架构，其客户端包含一个或多个在用户的电脑上运行的程序，而服务器端有两种，一种是数据库服务器端，客户端通过数据库连接访问服务器端的数据；另一种是Socket服务器端，服务器端的程序通过Socket与客户端的程序通信。 C／S是一种分布式系统结构，它基于简单的请求／应答协议，在C／S模式下，服务器只集中管理数据，而计算任务分散在客户机上，客户机和服务器之间通过网络协议来进行通讯。 客户机向服务器发出数据请求，服务器将数据传送给客户机进行计算，这种模式的优点充分利用了客户机的性能，使计算能力大大提高； 另外，由于客户机和服务器之间的通讯是通过网络协议进行的，是一种逻辑的联系，因此物理上在客户机和服务器两端是易于扩充的。 两层C／S结构应用软件的开发工作主要集中在客户端，客户端软件不但要完成用户交互和数据显示，而且还要完成对应用逻辑的处理，即用户界面与应用逻辑位于同一个平台上。 C/S架构的优点： 1 C/S架构的界面和操作可以很丰富。（客户端操作界面可以随意排列，满足客户的需要） 2 安全性能可以很容易保证。（因为只有两层的传输，而不是中间有很多层。 3 由于只有一层交互，因此响应速度较快。（直接相连，中间没有什么阻隔或岔路，比如QQ，每天那么多人在线，也不觉得慢） C/S架构的缺点： 可以将QQ作为类比： 1 适用面窄，通常用于局域网中。 2 用户群固定。由于程序需要安装才可使用，因此不适合面向一些不可知的用户。 3 维护成本高，发生一次升级，则所有客户端的程序都需要改变。 B/S架构的全称为Browser/Server，即浏览器/服务器结构。 Browser指的是Web浏览器，极少数事务逻辑在前端实现，但主要事务逻辑在服务器端实现。 B/S架构的系统无须特别安装，只有Web浏览器即可。 其实就是我们前端现在做的一些事情，大部分的逻辑交给后台来实现，我们前端大部分是做一些数据渲染，请求等比较少的逻辑。 与C/S架构只有两层不同的是，B/S架构有三层，分别为： 第一层表现层：主要完成用户和后台的交互及最终查询结果的输出功能。 第二层逻辑层：主要是利用服务器完成客户端的应用逻辑功能。 第三层数据层：主要是接受客户端请求后独立进行各种运算。 B/S架构的优点： 1、客户端无需安装，有Web浏览器即可。2、BS架构可以直接放在广域网上，通过一定的权限控制实现多客户访问的目的，交互性较强。3、BS架构无需升级多个客户端，升级服务器即可。可以随时更新版本，而无需用户重新下载啊什么的。 B/S架构的缺点： 1、在跨浏览器上，BS架构不尽如人意。2、表现要达到CS程序的程度需要花费不少精力。3、在速度和安全性上需要花费巨大的设计成本，这是BS架构的最大问题。4、客户端服务器端的交互是请求-响应模式，通常需要刷新页面，这并不是客户乐意看到的。（在Ajax风行后此问题得到了一定程度的缓解） BS====&gt;浏览器+服务器 只要有浏览器就可以 CS——-&gt;客户端+服务器. 必须的在客户端安装程序. 现在基本上开发的都是BS程序 8.1.2 Web 资源web即表示网页的意思，它用于表示Internet主机上供外界访问的资源（文件、程序）。 Internet上供外界访问的Web资源分为： • 静态web资源（如html 页面）：一般客户端发送请求到web服务器，web服务器从内存取到相应的文件，返回给客户端，客户端解析并渲染显示出来。web页面中供人们浏览的数据始终是不变。 • 动态web资源：一般客户端请求的动态资源，先将请求交于web容器，web容器连接数据库，数据库处理数据之后，将内容交给web服务器，web服务器返回给客户端解析渲染处理。web页面中供人们浏览的数据是由程序产生的，不同时间点访问web页面看到的内容各不相同。 静态资源和动态资源的区别 a.静态资源一般都是设计好的html页面，而动态资源依靠设计好的程序来实现按照需求的动态响应； b.静态资源的交互性差，动态资源可以根据需求自由实现； c.在服务器的运行状态不同，静态资源不需要与数据库参于程序处理，动态可能需要多个数据库的参与运算。 8.2 XMLExtensible Markup Language 可扩展标记语言 可扩展指的是用户可以按照XML的规则自定义标记。 什么是 XML? XML 指可扩展标记语言（EXtensible Markup Language） XML 是一种标记语言，很类似 HTML XML 的设计宗旨是传输数据，而非显示数据 XML 标签没有被预定义。需要自行定义标签。 XML 被设计为具有自我描述性。 XML 是 W3C 的推荐标准 1234567&lt;? xml version="1.0" encoding="UTF-8"? &gt;&lt;中国&gt; &lt;四川&gt; &lt;城市&gt;成都&lt;/城市&gt; &lt;城市&gt;都江堰&lt;/城市&gt;&lt;/四川&gt;&lt;/中国&gt; 第一行是 XML 声明。它定义 XML 的版本 (1.0) 和所使用的编码 XML和HTML都是标记文本： XML用于传输和存储数据，HTML用于显示数据 XML严格区分大小写 格式良好的XML有且只有一个根元素 XML中的空格不会自动删除，HTML中的空格是自动过滤的 XML中的标记是需要自行定义，并且可扩展，而HTML中的标记是预定义的 8.2.1 XML 语法所有 XML 元素都须有关闭标签 XML 标签对大小写敏感 XML 必须正确地嵌套 XML 文档必须有根元素XML 文档必须有一个元素是所有其他元素的父元素。该元素称为根元素 12345&lt;root&gt; &lt;child&gt; &lt;subchild&gt;.....&lt;/subchild&gt; &lt;/child&gt;&lt;/root&gt; XML 的属性值须加引号 实体引用在 XML 中，一些字符拥有特殊的意义。 如果你把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。 &lt; &lt; 小于 &gt; &gt; 大于 &amp; &amp; 和号 &apos; ‘ 单引号 &aquot; “ 引号 8.2.2 DTD 约束在XML文档中，定义了一套规则对文档中的内容进行约束，这套约束被称为XML约束，最常用的约束语言是DTD和Schema. http://www.w3school.com.cn/dtd/dtd_intro.asp 文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。 DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。 1. 内部的 DOCTYPE 声明假如 DTD 被包含在您的 XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中： 1&lt;!DOCTYPE 根元素 [元素声明]&gt; 1234567891011121314&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE note [ &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget the meeting!&lt;/body&gt;&lt;/note&gt; !DOCTYPE note (第二行)定义此文档是 note 类型的文档。 !ELEMENT note (第三行)定义 note 元素有四个元素：”to、from、heading,、body” !ELEMENT to (第四行)定义 to 元素为 “#PCDATA” 类型 !ELEMENT from (第五行)定义 from 元素为 “#PCDATA” 类型 !ELEMENT heading (第六行)定义 heading 元素为 “#PCDATA” 类型 !ELEMENT body (第七行)定义 body 元素为 “#PCDATA” 类型 2. 外部文档声明假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中： 1&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; 1&lt;!DOCTYPE 根元素 PUBLIC "DTD名称" "外部DTD文件的URI"&gt; 这个 XML 文档和上面的 XML 文档相同，但是拥有一个外部的 DTD: （在 IE5 中打开，并选择“查看源代码”命令。） 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;&lt;note&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 这是包含 DTD 的 “note.dtd” 文件： 12345&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt; XML 文档构建模块所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成： 元素 属性 实体 PCDATA CDATA PCDATA PCDATA 的意思是被解析的字符数据（parsed character data）。 可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。 PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。 文本中的标签会被当作标记来处理，而实体会被展开。 不过，被解析的字符数据不应当包含任何 &amp;、&lt; 或者 &gt; 字符；需要使用 &amp;、&lt; 以及 &gt; 实体来分别替换它们。 CDATA CDATA 的意思是字符数据（character data）。 CDATA 是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。 在一个 DTD 中，元素通过元素声明来进行声明。 声明一个元素 在 DTD 中，XML 元素通过元素声明来进行声明。元素声明使用下面的语法： 1&lt;!ELEMENT 元素名称 类别&gt; 或者 1&lt;!ELEMENT 元素名称 (元素内容)&gt; 空元素 空元素通过类别关键词EMPTY进行声明： 1&lt;!ELEMENT 元素名称 EMPTY&gt; 1&lt;!ELEMENT br EMPTY&gt; 1&lt;br /&gt; 属性声明使用下列语法： 1&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt; 8.3 HTTP8.3.1 http/https需要单独学习计算机网络 Http与Https的区别： HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头 HTTP 是不安全的，而 HTTPS 是安全的 HTTP 标准端口是80 ，而 HTTPS 的标准端口是443 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层 HTTP 无法加密，而HTTPS 对传输的数据进行加密 HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书 HTTP—Hyper Text Transfer Protocol，超文本传输协议，是一种建立在TCP上的无状态连接，整个基本的工作流程是客户端发送一个HTTP请求，说明客户端想要访问的资源和请求的动作，服务端收到请求之后，服务端开始处理请求，并根据请求做出相应的动作访问服务器资源，最后通过发送HTTP响应把结果返回给客户端。其中一个请求的开始到一个响应的结束称为事务，当一个事物结束后还会在服务端添加一条日志条目。 http://blog.51cto.com/13570193/2108347 HTTP请求是客户端往服务端发送请求动作，告知服务器自己的要求。 HTTP请求由状态行、请求头、请求正文三部分组成： 状态行：包括请求方式Method、资源路径URL、协议版本Version； 请求头：包括一些访问的域名、用户代理、Cookie等信息； 请求正文：就是HTTP请求的数据。 备注：请求方式Method一般有GET、POST、PUT、DELETE，含义分别是获取、修改、上传、删除，其中GET方式仅仅为获取服务器资源，方式较为简单，因此在请求方式为GET的HTTP请求数据中，请求正文部分可以省略，直接将想要获取的资源添加到URL中。下图所示就是GET的请求，没有请求正文。详细的说明在下边。 ​ 现在大多数协议版本为http/1.1 ​ 下图所示为POST请求的格式，有状态行、请求头、请求正文三部分。 HTTP响应 1 响应数据格式 ​ 服务器收到了客户端发来的HTTP请求后，根据HTTP请求中的动作要求，服务端做出具体的动作，将结果回应给客户端，称为HTTP响应。 ​ HTTP响应由三部分组成：状态行、响应头、响应正文； 状态行：包括协议版本Version、状态码Status Code、回应短语； 响应头：包括搭建服务器的软件，发送响应的时间，回应数据的格式等信息； 响应正文：就是响应的具体数据。 ​ 备注：我们主要关心并且能够在客户端浏览器看得到的是三位数的状态码，不同的状态码代表不同的含义，其中 1xx 表示HTTP请求已经接受，继续处理请求 2xx 表示HTTP请求已经处理完成 3xx 表示把请求访问的URL重定向到其他目录 4xx 表示客户端出现错误 5xx 表示服务端出现错误 具体HTTP响应实例如下图： 8.4 Tomcat一个动态的Web资源(项目)开发完毕后 ，需要发布到Web服务器中才能被外界访问。 Tomcat不仅具有服务器基本功能，还提供了数据库连接池等许多通用组件功能。 是Sun公司推荐的运行Servlet和JSP的容器（引擎）。 我电脑中安装了Tomcat9的版本 下载压缩包：http://tomcat.apache.org/，解压到指定目录即可完成Tomcat安装。 打开安装目录，双击startup.bat文件（bin目录下）便会启动Tomcat服务器， 在浏览器地址栏中输入http://localhost:8080或http://127.0.0.1:8080即可访问Tomcat服务器。 在Tomcat中运行的Web资源都是以Web应用形式呈现的。Web应用（Web应用程序或Web工程）指多个Web资源按照一定的结构组成的集合。 一个Web应用由多个Web资源或其他文件组成，其中包括html文件，css文件，js文件，动态Web页面、Java程序、支持jar包、配置文件等。 Tomcat的Web应用的目录结构： Web应用目录：Web应用的根目录，可以存放所有的Web资源。 ​ WEB-INF：根目录下的子目录，所有的配置文件都存放在这个目录中 ​ classe目录：存放各种class文件 ​ lib目录：存放Web应用所需要的各种jar文件。 WEB-INF目录下的web.xml文件可以配置默认的访问页面。 Tomcat服务器安装conf目录下的web.xml文件的配置： 12345&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 元素用于配置默认页面列表，它包括多个子元素， 每个 子元素都可以指定一个页面文件。当用户访问Web应用时，如果没有指定具体要访问的页面资源，Tomcat则会按照 元素指定默认页面的顺序，依次查找这些默认页面，如果找到，则将其返回给用户，并停止查找后面的默认页面，如果没有找到，则返回访问资源不存在的错误提示页面。 在实际项目中，如果要配置默认页面，则只需在Web应用的web.xml文件内按照上面的配置方式添加默认的页面信息。例如，将应用中的welcome.html页面配置为默认页面，只需在web.xml中进行如下配置： 123&lt;welcome-file-list&gt; &lt;welocme-file&gt;welcome.html&lt;/welocme-file&gt;&lt;/welcome-file-list&gt; 配置完成后，项目的默认访问页面就是welcome.html。 在Eclipse中配置Tomcat 哈哈哈哈，百度即可，很easy的。 Windows—Preferences—Server—Runtime Environments—Add,选择Aphache Tomcat 版本。。。。 9.1 ServletServlet是使用Java语言编写的运行在服务器端的程序，通常来说，Servlet是指所有实现了Servelt接口的类。 Servlet主要用于处理客户端传来的HTTTP请求，并返回一个响应，它能够处理的请求有doGet()和doPost()等。 Servlet由Servlet容器提供，Servlet容器是指提供了Servlet功能的服务器（如Tomcat）。Servlet容器会将Servlet动态加载到服务器上，然后通过HTTP请求和HTTP响应与客户端进行交互。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu + Django2.1.2 +Python3]]></title>
    <url>%2Fpost%2Feeec02ce.html</url>
    <content type="text"><![CDATA[Ubuntu + Django2.1.2 +Python31、简单博客系统1.1 Django 入门1.1.1 Djangodjango -网站的开发框架 1.1.2 安装Django(Python3)打开终端 $ pip3 install Django == 2.1.2 1.1.3 创建项目（project)“项目”，可以理解为一个网站 首先，创建一个目录mysite（文件夹），将项目创建在这个mysite里 打开终端 $ sudo install python-django-common $ sudo apt-get install python - django 然后在这个mysite目录下（空白），右键，选择Open in Terminal ~/mysite$ django-admin startproject mysite —-创建一个django项目，多了一个mysite子目录，mysite是这个项目名称，这时已经有了一个网站的基本框架了。 创建项目时用到的 django-admin.py，它是Django 的任务管理命令行工具 在有manage.py这个文件的目录下打开终端$ python manage.py runserver 若一切正常，可以看到提示信息： Starting development server at http://127.0.0.1:8000/ ——启动服务 Quit the server with CONTROL-C. ——control+c 结束当前服务 打开浏览器，输入http://12.0.1:8000或者http://localhost:8000 ,会看到Django网页 1.1.4 创建应用(application)网站的具体功能 进入到刚才创建的项目目录中，即manage.py文件所在的目录 ~/mysite$ python manage.py startapp blog ——在项目mysite中新建了一个blog应用。 对项目结构各个部分简介 1. manage.py在创建一个Django项目后，manage.py 被自动生成在项目的根目录中，它是对django-admin.py的简单封装，同样能够实现命令行操作，不要修改和删除它。 2. mysite所建项目的管理功能目录，它里面的文件常用于整个项目进行参数配置 settings.py : 包含项目的初始化设置，可以针对整个项目进行有关参数配置，比如配置数据库、添加应用等。 urls.py: URL配置表文件，主要将URL映射到应用程序上。当用户请求某个URL时，Django项目会根据这个文件中的映射关系指向某个目标对象（某个应用的urls.py文件或某个具体的视图函数）。这个文件也被称为URLconf. wsgi.py : （Web Server Gateway Interface),是Python所选择的服务器和应用标准。 __pychache__: 执行python manage.py runserver命令后出现，时一个编译后的文件夹，里面文件都是以.pyc结尾的文件。 3. blog项目中创建的应用之一，每创建一个新的应用，Django就会在项目根目录中( ./)中创建一个子目录，目录中会有一些默认的文件。 admin.py : 可以自定义Django管理工具。 apps.py : 包含对应用的配置 migrations: 这是一个目录，用于存储应用的数据库表结构的指令，通过这些指令可以修改和创建数据库，从而在models.py模型类和数据库表之间的迁移。 models.py : 应用的数据模型，每个Django应用都应当有一个models.py文件，可以为空。 tests.py：在这个文件中编写测试文档来测试所建立的应用。 views.py: 用户保存响应各种请求的函数和类。 如果编写的是函数，则称之为基于函数的视图；如果编写的是类，则称之为基于类的视图。保存函数或者类的视图文件。 4. db.sqlite3默认的数据库SQLite 1.1.5 网站的配置将应用注册到项目中 在Django项目中，主管信息注册（对本项目进行各种信息声明）的文件时./mysite/settings.py。 DEBUG： True or False, 开发过程中，设置成True,在测试功能时，Django能够显示详细的报错信息——“开发模式”。如果将项目部署到真正要对外发布的服务器上——“生产环境”，必须将其值修改为False,从而避免暴露项目的内部信息。 ALLOWED_HOSTS: 在DEBUG设置为True时，其值可以为空。当部署到生产环境中时，要把主域名填写到这里，才能通过域名访问到本网站。 INSTALLED_APPS： 所有的应用写到这里才能生效。 INSTALLED_APPS = [ ‘django.contrib.admin’, # 针对项目后台管理的应用。 ‘django.contrib.auth’, ‘django.contrib.contenttypes’, ‘django.contrib.sessions’, ‘django.contrib.messages’,​ ‘django.contrib.staticfiles’, ​ ‘blog’, #新增加的，所建立项目的名称，其他项Django默认具有的应用。 ] DATABASES: 配置数据库，默认配置SQLite,小巧灵活，Python标准库所支持。 LANGUAGE_CODE:设置项目的语言，汉语，设置为 LANGUAGE_CODE = ‘zh-hans’ TIME_ZONE: 设置时区，东八区， TIME_ZONE = ‘Asia/Shanghai’ 1.1.6 知识点1. 开发模式是相对于“生产模式”而言的，即系统尚处于开发阶段，还没正式对外部客户提供服务，在Django开发模式中，不需要配置Apache或者Nginx等服务器，也能够运行网站，这是因为Django本身就提供了简单的Web服务器功能，但是这仅限于开发过程，当网站被正式部署后，即转换为“生产模式”时，就需要对部分配置进行修改。 在开发模式中，Django会自动检测到修改代码并重新加载，不需要每次修改代码后重新启动Web服务器。只有在新增加文件后，才需要重启Django服务。 运行Django服务的指令是： python manage.py runserver 2. 项目和应用Django安装好之后，就有了django-admin这个默认命令，可以用django-admin starproject projectname命令创建一个Django项目。 项目是由若干个“应用”(app)组成的，实现具体的功能。创建应用可以用 python manage.py startapp appname命令。也可以使用 django-admin startapp appname命令。 创建项目和应用后，会生成一些默认的文件，要么是一些默认的配置，要么是一些空文件为了占据位置。 每个应用都要在项目的settings.py文件的INSTALLED_APPS中进行声明，告诉Django这个应用是本项目的一部分。 1.2 编写博客的数据模型类设计数据库和表结构是做网站的基础。在Django中，不需要通过SQL语句直接跟数据库打交道，而是完全用 python的方式创建数据库，之后交给Django完成数据库的操作。 1.2.1 数据模型类利用Django开发网站系统，一般情况下，要先编写数据模型，就是在./blog/models.py中写一个类，这个类与数据库中的数据表具有对应关系。 在./blog/models.py中编写博客的数据模型类 Blog, 它本质上是一个继承了django.db.models.Models的类。 12345678910111213141516171819from django.db import modelsfrom django.utils import timezonefrom django.contrib.auth.models import Userclass BlogArticles(models.Model): title = models.CharField(max_length=300) #1 author = models.ForeignKey(User,related_name=&quot;blog_posts&quot;,on_delete=models.CASCADE,) #2 body = models.TextField() publish = models.DateTimeField(default=timezone.now) class Meta: #3 ordering = (&quot;-publish&quot;,) def __str__(self): return self.title 这个BlogArticles类中定义了一些属性，每个属性对应着将来数据库表中的一个字段。，以后将属性称之为字段。 #1 字段title的属性为CharFiled()类型，参数说字 段的最大数量. #2 通过字段author规定了博客和用户之间的关系——一个用户对应多篇文章。ForeignKey() 就反映了这种“一对多”关系。类User就是BlogArticles的对应对象，related_name=”blog_posts”的作用是允许通过类User反向查询到BlogArticles. #3 通过 ordering = (“-publish”,)，规定了BlogArticles实例对象的显示顺序，即按照publish字段值的倒序显示。 BlogArticles 类的数据模型编写好了，将来数据库表的基本结构就是按照上述各字段及其属性而定的。 接下来根据数据模型建立数据库表： 在/mysite/manage.py 位置执行 ~/mysite$ python manage.py makemigrations,会有Migrations for blog : …的提示信息，意思就是在blog/migrations目录中创建了一个BlogArticles模型，打开这个001_initial.py文件看一下。 12345678910111213141516171819202122232425262728293031# Generated by Django 2.1.2 on 2018-10-13 12:21from django.conf import settingsfrom django.db import migrations, modelsimport django.db.models.deletionimport django.utils.timezoneclass Migration(migrations.Migration): initial = True dependencies = [ migrations.swappable_dependency(settings.AUTH_USER_MODEL), ] operations = [ migrations.CreateModel( name=&apos;BlogArticles&apos;, fields=[ (&apos;id&apos;, models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=&apos;ID&apos;)), (&apos;title&apos;, models.CharField(max_length=300)), (&apos;body&apos;, models.TextField()), (&apos;publish&apos;, models.DateTimeField(default=django.utils.timezone.now)), (&apos;author&apos;, models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name=&apos;blog_posts&apos;, to=settings.AUTH_USER_MODEL)), ], options=&#123; &apos;ordering&apos;: (&apos;-publish&apos;,), &#125;, ), ] 这个文件是执行python manage.py makemigrations命令后，django自动生成的。这个文件的功能是创建一个名称为BlogArticles的数据库表。这个表的名称由两部分组成，第一部分是blog本应用的名称，第二部分是blogaricles(都小写)是在models.py中创建的数据模型类的名称，中间用单下划线连接。 创建了一个能够建立数据库表的文件，就可以真正创建数据库了。 1~/mysite$ python manage.py migrate 本项目使用SQLite数据库，并且在settings.py中规定了数据库文件存放在项目根目录中 123456DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.sqlite3&apos;, &apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;), &#125;&#125; 对于db.sqlite3这个文件，可以在FireFox浏览器中安装SQLite Manager 插件来查看。 由于我的火狐浏览器插件不兼容，两种办法：1、直接在Ubuntu Software 搜索 sqlite ,安装DB Browser for SQLite； 2是通过打开终端输入命令： 123sudo apt-get install sqlite3sqlite -versionsudo apt-get install sqlitebrowser 综上，博客的数据库就建立好了。 1.2.2 发布博客文章先用最简单的方式实现博客文章的发布,使用Django默认的管理功能就可以发布文章。要使用此功能，必须先创建超级管理员。要牢记所使用的用户名和密码。密码设置要有一定的复杂度，我的是英文字母加数字，至少8位。 123456mysite$ python manage.py createsuperuserUsername(leave blank to use &apos;qiwsir&apos;): kunEmail address: hk19930914@163.comPassword:*********Password(again):*********Superuser created successfull 运行服务器 mysite$ python manage.py runserver 浏览器地址栏输入 http://127.0.0.1:8000/admin/或者http://localhost:8000/admin/, 然后输入刚才创建超级管理员的用户名和密码，就可以进入Django administration页面。 用户(Users)和组(Groups)是Django在用户管理应用中默认的，单击User会看到当前项目仅有的一个用户kun，当然也可以增加用户。 打开./blog/admin.py文件，用编辑工具打开，输入以下代码： 1234from django.contrib import adminfrom .models import BlogArticles #1 将BlogArticles类引入当前环境admin.site.register(BlogArticles) #2 将该类注册到admin中 刷新浏览器页面，看到新注册的BLOG。 单击Blog articless 右侧的Add按钮就可以添加博客文章。内容填写之后，点击保存，该博客文章被保存到数据库中，可以使用DB Browser for SQLite查看数据库。 在./blog/models.py中使用了django.utils.timezone,所以要安装一个pytz模块，用它来提供时区。 1$ sudo pip3 install pytz 安装完毕，重启服务。 在文章列表页，可以看到所有已经发布的文章标题。由于显示的列表信息太单一，为了使列表页的信息更加丰富，继续用编辑./blog/admin.py 文件。 12345678910111213from django.contrib import adminfrom .models import BlogArticlesclass BlogArticlesAdmin(admin.ModelAdmin): list_display = (&quot;title&quot;, &quot;author&quot;, &quot;publish&quot;) list_filter = (&quot;publish&quot;, &quot;author&quot;) search_fields = (&apos;title&apos;, &quot;body&quot;) raw_id_fields = (&quot;author&quot;,) date_hierarchy = &quot;publish&quot; ordering = [&apos;publish&apos;, &apos;author&apos;]admin.site.register(BlogArticles, BlogArticlesAdmin) 保存，刷新浏览器页面，即可看到效果。 1.2.3 知识点1. HTTPHyper Text Transfer Protocol( 超文本传输协议 )，是客户端( 浏览器、网页爬虫程序 )和服务器端( 网站 )请求和应答的标准(TCP)，封装了Web服务的整个过程，默认端口80。 请求 (request): 客户端到服务器端 响应 (response): 服务器端到客户端。状态信息（HTTP/1.1 200) 和内容信息。 HTTP/1.1 协议共定义了8种请求方式：OPTIONS、HEAD、GET、POST、 PUT、DELETE、TRACE 和 CONNECT. 本项目中主要使用GET和POST请求 GET：向指定服务器发出请求，主要用于读取信息并显示 POST： 向指定服务器提交数据，请求服务器进行处理（例如提交表单或者上传文件） HTTPS — Hyper Text Transfer Protocol Secure,默认端口443，安全性更高，HTTP以明文方式封装信息，HTTPS以加密方式传送信息。 2. URLUniform/Universal Resource Locator 统一资源定位符，俗称网址。 URL标准格式：协议类型://服务器地址(必要时需加上端口号)/路径/文件名 协议类型：HTTP/HTTPSu 服务器地址： 通常是域名，比如baidu.com,也可以是IP地址，如果默认是80端口，可以不写，否则需要写上端口。 路径：以”/“区别目录，对于GET请求方式，可以用“？”发起参数，每个参数以“&amp;”隔开，再以“=”分开参数名称和值。 文件名：有必要可写 3. 模型： ORM动态网站，大多数是通过数据库实现对数据的保存和读取，所以数据库是网站最基本最底层的组成部分。 Django不需要开发者使用SQL语句实现程序和数据库的交互，而是通过ORM，即Object-Relational Mapping（对象关系映射）。 ORM的作用是在关系型数据库和业务实体对象之间进行映射，，只需简单地操作对象的属性和方法。 Django的数据模型层大量使用ORM,表现方式就是编写数据模型类，这些类可以写到任何文件中，通常写在每个应用的models.py文件中，每个数据模型类都是django.db.models.Model的子类。应用的名称（小写字母）和数据模型类的名称（小写字母）共同组成一个数据库表的名称（”appname”_”modelname”,例如blog_blogarticles). 当数据模型类写好之后，通过执行Django的数据迁移操作（python manage.py makemigrations, python manage.py migrate)就能够创建相应的数据库表，用来保存网站项目的数据。以后要更改数据库表的结构，只需要更改数据模型类，迁移数据就能实现数据库结构的调整。 若想改为MySQL数据库,只需要在settings.py文件中做好新数据库的配置，然后进行迁移数据的操作即可完成数据库的迁移，不需要对ORM进行任何修改。]]></content>
      <categories>
        <category>Python3 Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建相册]]></title>
    <url>%2Fpost%2Feb6ee242.html</url>
    <content type="text"><![CDATA[1.原本Next教程：https://www.jianshu.com/p/8b5ace0093072.本网站：创建gallery hexo new page galleryhexo source gallery index.md 图片名 为一个图片]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 自定义页面如何避免被渲染]]></title>
    <url>%2Fpost%2F4d280a8b.html</url>
    <content type="text"><![CDATA[自定义网页与渲染网页可以是自己编写的，也可以是别人现成的源码。网页编写完成后，在 Hexo\source 目录下创建一个文件夹，文件夹名称任意，将 Html 文件放置于此文件夹，并重命名为 index.html 。 Hexo 博客大部分都呈现出一种高度的统一化与规范化，所见文章都是经由渲染的静态网页，而静态网页的样式都直接由 Hexo 的主题控制。之前在加入自定义机器人页面时，为了避免被渲染，是将Hexo\source 的件夹中的 index.md 文件删除，然后在Hexo\public文件夹下新建robot文件夹，然后将index.html放入，坏处就是每次hexo clean后，数据总会被清理，得需要重新复制，十分麻烦！ 好在Hexo 提供了跳过渲染功能。 方法一在html文件中添加跳过渲染指令： 用编辑器打开 Hexo\source 创建的文件夹中的 index.html 文件，在开头添加如下代码即可 123---layout: false--- 添加该指令后，执行 hexo g 命令时便会跳过该 index.html 文件，使得 index.html 不受当前 hexo 主题影响，完全是一个独立的网页。 如果网页引用了 css 或 js ，这些 css 和 js 必须使用外链。 如果引用图片，可以在网页目录下建立 img 文件夹，可以直接引用图片，不必再去创建外链。 方法二使用编辑器打开 Hexo 目录下的_config.yml 文件，找到 skip_render skip_render 一般有以下四种常用参数： 跳过source目录下的 test.html: skip_render: test.html 跳过source目录下 test 文件夹内所有文件：skip_render: test/* 跳过source目录下 test 文件夹内所有文件包括子文件夹以及子文件夹内的文件：skip_render: test/** 跳过多个路径： 123skip_render: - test.html - test/* 对格式要求严格，注意填写参数时的格式，添加完成后便不会渲染指定文件/文件夹。 如果网页引用了 css 或 js ，并将整个网页目录设置为跳过渲染，则不必再为 css 和 js 创建外链，可以直接引用。]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客优化(3)]]></title>
    <url>%2Fpost%2F3c51e5b6.html</url>
    <content type="text"><![CDATA[设置头像边框为圆形框及实现鼠标放置头像上旋转的特效新版的Next7，图片可以链接网址或者把图片放入 themes/next/source/images 下,修改 avatar。无需修改hemes/next/source/css/_common/components/sidebar/sidebar-author.syl文件，只需要将themes/next/_config.yml修改如下即可： 123456789101112# Sidebar Avataravatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.gif # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: true 设置网站的图标Favicon在图标网站找一张你喜欢的图标（大：32x32 小：16x16），图标网站：easyicon或者阿里巴巴矢量图标库。将下载下来的小图和中图放在Blog/themes/next/source/images，将默认的两张图片替换掉。themes/next/_config.yml,若自定义了图片名字，需要做修改： 1234favicon: small: /images/favicon-16x16-next.png //16X16小图 medium: /images/favicon-32x32-next.png //32X32大图 ...]]></content>
      <tags>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客优化(2)]]></title>
    <url>%2Fpost%2F254ad4f7.html</url>
    <content type="text"><![CDATA[首页文章间距过款打开\themes\next\source\css\_schemes\Mist\_posts-expanded.styl ，在最后一行添加 1234posts-expand .post &#123; margin-top: 30px; margin-bottom: 30px;&#125; 显示文章字数统计,阅读时长,总字数cd 到站点根目录下 1$ npm i --save hexo-wordcount 打开站点(hexo)的_config.yml，添加 12345symbols_count_time: symbols: true time: true total_symbols: true total_time: false 打开 themes/next/_config.yml ，搜索关键字 post_wordcount： 123456symbols_count_time: separated_meta: true item_text_post: true item_text_total: true awl: 4 wpm: 275 实现点击出现桃心效果cd 进 路径 /themes/next/source/js/src 新建(touch love.js)并将以下代码复制进去并保存： 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 然后打开 \themes\next\layout\_layout.swig 文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 内容区域的宽度就是文章的框框 Next主题在电脑上阅读文章时内容两边留的空白较多，这样在浏览代码块时经常要滚动滚动条才能阅读完整，体验不是很好，下面提供修改内容区域的宽度的方法。 NexT 对于内容的宽度的设定如下(移动设备下，宽度自适应): 在Mist和Muse风格编辑主题的 source/css/_variables/custom.styl 样式文件，新增变量，即可修改宽度： 12345// 700px，当屏幕宽度 &lt; 1600px$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 当使用Pisces风格：123header&#123; width: 90%; &#125;.container .main-inner &#123; width: 90%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125; 博文的置顶和排序打开Hexo站点下node_modules/hexo-generator-index/lib/generator.js文件，代码全部替换 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 打开文章添加top字段,设置数值，数值越大文章越靠前： 1234title: *****date: *****tags: ****top: 100 修改文章底部的那个带#号的标签打开 themes/next/layout/_macro/post.swig 文件,搜索 rel=&quot;tag&quot;&gt;# ,将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 浏览页面的时候显示当前浏览进度打开 themes/next/_config.yml ,搜索关键字 scrollpercent ,把 false 改为 true。 12# Scroll percent label in b2t buttonscrollpercent: true 如果想把 top按钮放在侧边栏,打开 themes/next/_config.yml ,搜索关键字 b2t ,把 false 改为 true。 12345# Back to top in sidebar b2t: true # Scroll percent label in b2t button scrollpercent: true 每篇文章末尾统一添加“本文结束”标记在路径 /themes/next/layout/_macro 中cd新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:16px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-thumbs-up&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 打开 themes/next/layout/_macro/post.swig 文件,在post-body之后，post-footer之前（post-footer之前两个DIV）添加： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; 然后打开主题配置文件 _config.yml,在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag:enabled: true]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo v3.8.0 +NexT.Mist v7.0.1 博客优化(1)]]></title>
    <url>%2Fpost%2F6cd3ce39.html</url>
    <content type="text"><![CDATA[给网站加上问答机器人第一种方法，由于不会前端方面的知识，就直接在socia引入url取个巧吧，等以后学会JavaScript之后再写个聊天界面接入网页中吧; 另外一种方法是新建一个page , hexo new page “robot”,在根目录下产生一个robot文件夹,删除里面的index.md,然后在根目录下的public文件夹里新建一个robot文件夹，将index.html文件拷贝进去（html+css+javascript), hexo d,这也是自定义网页的方法，不过hexo clean后，public文件夹就会被清理，所以要备份你自定义的index.html文件。 为了节省menu,我也把这个网页设成网址放在social里,不过每天回答的次数有限制。。。。 网页中插入音乐外链播放器——-layout/_macro/sidebar.swig文件网页云音乐由于版权问题无法生成外链播放器，故选取猫耳FM 外链HTML代码贴在想要放的位置，我把它放在尺寸自动播放代码里可以调 我把它插在侧边栏里，对应在layout/_macro/sidebar.swig文件里 1&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="310" height="300" src="https://www.missevan.com/albumiframe/1861550?autoplay=false&amp;playlist=true"&gt;&lt;/iframe&gt; 首页文章不全文显示，调成预览模式方法1主题配置文件进入hexo博客项目的themes/next目录 用文本编辑器打开_config.yml文件 搜索”auto_excerpt”,改为true以及设置显示长度 方法2 在你想要截断的地方加符号用md写的话，在文章里加&lt;!1— more —&gt; 会自动截断（我加1是为了不以这结尾） 主页文章添加阴影效果就是文章外面那个框框 打开\themes\next\source\css\_custom\custom.styl,向里面加入： 123456.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); 文章出现两次阅读次数——leancloud和busuanzi重复的原因1、leancloud(true时首页预览模式和文章页均可看到阅读次数) 主题_config.yml文件 设置 visitor: false valine: … visitor: false 2、busuanzi(true时预览模式阅读次数不可见) 主题_config.yml文件 设置post_views: false busuanzi_count: …. post_views: false post_views_icon: eye 底部隐藏由Hexo强力驱动、主题—NexT.Mist打开Blog/themes/next/layout/_partials/footer.swig，注释掉相应代码。 1&lt;!--代码 --&gt; 12345678910111213141516171819202122232425262728&lt;!--&lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% if theme.footer.powered %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.custom_text %&#125; &lt;div class=&quot;footer-custom&quot;&gt;&#123;# #&#125;&#123;&#123; theme.footer.custom_text &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;--&gt; 添加底部桃心打开Blog/themes/next/layout/_partials/footer.swig搜索with-love，改成如下 12 &lt;span class=&quot;with-love&quot; id=&quot;animate&quot;&gt;&lt;i class=&quot;fa fa-heart&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[Kun少侠助手 #mysee{ position:fixed; left:9%; top:38%; width:82%; font-weight:100; text-align:center; font-size:32px; line-height:50px; margin:-120px auto; color:#000000; opacity:1; display:none; } #robot{ position:fixed; left:25%; top:52%; width:50%; padding-bottom:5px; padding-top:5px; font-weight:100; text-align:center; font-size:32px; line-height:50px; margin:-83px auto 0px auto; border:0px; opacity:0.5; background:transparent; border-bottom:1px solid #000000; color:#000000; outline:none; display:none; } #robot:focus,#robot:hover{ border:0px; color:#000000; border-bottom:1px solid #000000; background:transparent; line-height:50px; outline:none; opacity:1; } abbr, acronym, address, applet, article, aside, audio, b, big, blockquote, body, canvas, caption, center, cite, code, dd, del, details, dfn, dl, dt, em, embed, fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6, header, html, iframe, img, ins, kbd, label, legend, li, mark, menu, nav, object, ol, output, p, pre, q, ruby, s, samp, section, small, span, strike, strong, sub, summary, sup, table, tbody, td, tfoot, th, thead, time, tr, tt, u, ul, var, video { margin: 0; padding: 0; cursor: url('images/shubiao.ico'),auto; } 欢迎访问我的博客，有什么可以帮助您的？ var xmlHttp function showHint(str) { if (event.keyCode==13) { Send(str); } } function Send(str) { if (str.length==0) { document.getElementById("txtHint").innerHTML=""; return; } xmlHttp=GetXmlHttpObject() if (xmlHttp==null) { alert ("您的浏览器不支持AJAX！"); return; } var url="http://www.tuling123.com/openapi/api?key=993f24619fcc47ceaee905471b147f19"; url=url+"&info="+str; url=url+"&userid=1234" ; xmlHttp.onreadystatechange=stateChanged; xmlHttp.open("GET",url,true); xmlHttp.send(null); document.getElementById("robot").value=""; } function stateChanged() { if (xmlHttp.readyState==4) { var msg=eval('(' + xmlHttp.responseText + ')'); document.getElementById("txtHint").innerHTML=msg.text; } } function GetXmlHttpObject() { var xmlHttp=null; try { // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); } catch(e) { // Internet Explorer try { xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); } catch (e) { xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); } } return xmlHttp; } Kun少侠 L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"superSample":2,"width":100,"height":200,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.3},"log":false});]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fphotos%2Fdata.json</url>
    <content type="text"><![CDATA[{"list":[{"date":"2017-8-","arr":{"year":2017,"month":8,"link":["2017-8-6_张家界1.jpg","2017-8-03_梵净山2.jpg","2017-8-03_梵净山1.jpg"],"text":["张家界1","梵净山2","梵净山1"],"type":["image","image","image"]}},{"date":"2017-7-","arr":{"year":2017,"month":7,"link":["2017-7-31_西江千户苗寨2.jpg","2017-7-31_西江千户苗寨1.jpg","2017-7-26_安顺黄果树风景区1.jpg"],"text":["西江千户苗寨2","西江千户苗寨1","安顺黄果树风景区1"],"type":["image","image","image"]}}]}]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的相册]]></title>
    <url>%2Fphotos%2Findex.html</url>
    <content type="text"><![CDATA[Photos 图片正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('./ins.js') }, 0) })()]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fphotos%2Fins.css</url>
    <content type="text"><![CDATA[#post-instagram{ padding: 30px; } figure { margin: 0; } #post-instagram .article-entry{ padding-right: 0; } .instagram{ position: relative; min-height: 500px; } .instagram img { width: 100%; } .posts-expand .post-body img { padding: 0; border : 0; } .instagram .year { font-size: 16px; } .instagram .open-ins{ padding: 10px 0; color: #cdcdcd; } .instagram .open-ins:hover{ color: #657b83; } .instagram .year{ display: inline; } .instagram .thumb { width: 25%; height: 0; padding-bottom: 25%; position: relative; display: inline-block; text-align: center; background: #ededed; outline: 1px solid #ddd; } .instagram .thumb a { position: relative; } .instagram .album h1 em{ font-style: normal; font-size: 14px; margin-left: 10px; } .instagram .album ul{ display: flex; flex-wrap: wrap; clear: both; width: 100%; text-align: left; } .instagram .album li{ list-style: none; display: inline-block; box-sizing: border-box; padding: 0 5px; margin-bottom: -10px; height: 0; width: 25%; position: relative; padding-bottom: 25%; } .instagram .album li:before{ display: none; } .instagram .album div.img-box{ position: absolute; width: 90%; height: 90%; -webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); -moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); } .instagram .album div.img-box img{ width: 100%; height: 100%; position: absolute; z-index: 2; } .instagram .album div.img-box .img-bg{ position: absolute; top: 0; left: 0; bottom: 0px; width: 100%; margin: -5px; padding: 5px; -webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -webkit-transition: all 0.15s ease-out 0.1s; -moz-transition: all 0.15s ease-out 0.1s; -o-transition: all 0.15s ease-out 0.1s; transition: all 0.15s ease-out 0.1s; opacity: 0.2; cursor: pointer; display: block; z-index: 3; } .instagram .album div.img-box .icon { font-size: 14px; position: absolute; left: 50%; top: 50%; margin-left: -7px; margin-top: -7px; color: #999; z-index: 1; } .instagram .album div.img-box .img-bg:hover{ opacity: 0; } .photos-btn-wrap { border-bottom: 1px solid #e5e5e5; margin-bottom: 20px; } .photos-btn { font-size: 16px; color: #333; margin-bottom: -4px; padding: 5px 8px 3px; } .photos-btn.active { color: #08c; border: 1px solid #e5e5e5; border-bottom: 5px solid #fff; } @media screen and (max-width:600px) { .instagram .thumb { width: 50%; padding-bottom: 50%; } .instagram .album li { width: 100%; position: relative; padding-bottom: 100%; text-align: center; } .instagram .album div.img-box{ margin: 0; width: 90%; height: 90%; } }]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fphotos%2Fphotoswipe.css</url>
    <content type="text"><![CDATA[/*! PhotoSwipe main CSS by Dmitry Semenov | photoswipe.com | MIT license */ /* Styles for basic PhotoSwipe functionality (sliding area, open/close transitions) */ /* pswp = photoswipe */ .pswp { display: none; position: absolute; width: 100%; height: 100%; left: 0; top: 0; overflow: hidden; -ms-touch-action: none; touch-action: none; z-index: 1500; -webkit-text-size-adjust: 100%; /* create separate layer, to avoid paint on window.onscroll in webkit/blink */ -webkit-backface-visibility: hidden; outline: none; } .pswp * { -webkit-box-sizing: border-box; box-sizing: border-box; } .pswp img { max-width: none; } /* style is added when JS option showHideOpacity is set to true */ .pswp--animate_opacity { /* 0.001, because opacity:0 doesn't trigger Paint action, which causes lag at start of transition */ opacity: 0.001; will-change: opacity; /* for open/close transition */ -webkit-transition: opacity 333ms cubic-bezier(0.4, 0, 0.22, 1); transition: opacity 333ms cubic-bezier(0.4, 0, 0.22, 1); } .pswp--open { display: block; } .pswp--zoom-allowed .pswp__img { /* autoprefixer: off */ cursor: -webkit-zoom-in; cursor: -moz-zoom-in; cursor: zoom-in; } .pswp--zoomed-in .pswp__img { /* autoprefixer: off */ cursor: -webkit-grab; cursor: -moz-grab; cursor: grab; } .pswp--dragging .pswp__img { /* autoprefixer: off */ cursor: -webkit-grabbing; cursor: -moz-grabbing; cursor: grabbing; } /* Background is added as a separate element. As animating opacity is much faster than animating rgba() background-color. */ .pswp__bg { position: absolute; left: 0; top: 0; width: 100%; height: 100%; background: #000; opacity: 0; -webkit-transform: translateZ(0); transform: translateZ(0); -webkit-backface-visibility: hidden; will-change: opacity; } .pswp__scroll-wrap { position: absolute; left: 0; top: 0; width: 100%; height: 100%; overflow: hidden; } .pswp__container, .pswp__zoom-wrap { -ms-touch-action: none; touch-action: none; position: absolute; left: 0; right: 0; top: 0; bottom: 0; } /* Prevent selection and tap highlights */ .pswp__container, .pswp__img { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; } .pswp__zoom-wrap { position: absolute; width: 100%; -webkit-transform-origin: left top; -ms-transform-origin: left top; transform-origin: left top; /* for open/close transition */ -webkit-transition: -webkit-transform 333ms cubic-bezier(0.4, 0, 0.22, 1); transition: transform 333ms cubic-bezier(0.4, 0, 0.22, 1); } .pswp__bg { will-change: opacity; /* for open/close transition */ -webkit-transition: opacity 333ms cubic-bezier(0.4, 0, 0.22, 1); transition: opacity 333ms cubic-bezier(0.4, 0, 0.22, 1); } .pswp--animated-in .pswp__bg, .pswp--animated-in .pswp__zoom-wrap { -webkit-transition: none; transition: none; } .pswp__container, .pswp__zoom-wrap { -webkit-backface-visibility: hidden; } .pswp__item { position: absolute; left: 0; right: 0; top: 0; bottom: 0; overflow: hidden; } .pswp__img { position: absolute; width: auto; height: auto; top: 0; left: 0; } /* stretched thumbnail or div placeholder element (see below) style is added to avoid flickering in webkit/blink when layers overlap */ .pswp__img--placeholder { -webkit-backface-visibility: hidden; } /* div element that matches size of large image large image loads on top of it */ .pswp__img--placeholder--blank { background: #222; } .pswp--ie .pswp__img { width: 100% !important; height: auto !important; left: 0; top: 0; } /* Error message appears when image is not loaded (JS option errorMsg controls markup) */ .pswp__error-msg { position: absolute; left: 0; top: 50%; width: 100%; text-align: center; font-size: 14px; line-height: 16px; margin-top: -8px; color: #CCC; } .pswp__error-msg a { color: #CCC; text-decoration: underline; }]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[gallery]]></title>
    <url>%2Fgallery%2Findex.html</url>
    <content type="text"><![CDATA[2017 梵净山1 梵净山2 西江千户苗寨1 西江千户苗寨2 张家界1]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fphotos%2Fins.js</url>
    <content type="text"><![CDATA[/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = "/dist/"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type="video"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = ""; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = ""; for (var i = 0, len = data.link.length; i < len; i++) { var minSrc = 'https://raw.githubusercontent.com/HK0914/blog_photos/master/min_photos/' + data.link[i]; var src = 'https://raw.githubusercontent.com/HK0914/blog_photos/master/photos/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); src += ''; liTmpl += '\ \ \ \ ' + data.text[i] + '\ '; } ulTmpl = ulTmpl + '' + data.year + '年' + data.month + '月\ ' + liTmpl + '\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split("/"); return "/assets/ins/" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + "" + ((m + "").length == 1 ? "0" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', './data.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { console.log("lazyload") opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fphotos%2Fdefault-skin%2Fdefault-skin.css</url>
    <content type="text"><![CDATA[/*! PhotoSwipe Default UI CSS by Dmitry Semenov | photoswipe.com | MIT license */ /* Contents: 1. Buttons 2. Share modal and links 3. Index indicator ("1 of X" counter) 4. Caption 5. Loading indicator 6. Additional styles (root element, top bar, idle state, hidden state, etc.) */ /* 1. Buttons */ /* css reset */ .pswp__button { width: 44px; height: 44px; position: relative; background: none; cursor: pointer; overflow: visible; -webkit-appearance: none; display: block; border: 0; padding: 0; margin: 0; float: right; opacity: 0.75; -webkit-transition: opacity 0.2s; transition: opacity 0.2s; -webkit-box-shadow: none; box-shadow: none; } .pswp__button:focus, .pswp__button:hover { opacity: 1; } .pswp__button:active { outline: none; opacity: 0.9; } .pswp__button::-moz-focus-inner { padding: 0; border: 0; } /* pswp__ui--over-close class it added when mouse is over element that should close gallery */ .pswp__ui--over-close .pswp__button--close { opacity: 1; } .pswp__button, .pswp__button--arrow--left:before, .pswp__button--arrow--right:before { background: url(default-skin.png) 0 0 no-repeat; background-size: 264px 88px; width: 44px; height: 44px; } @media (-webkit-min-device-pixel-ratio: 1.1), (-webkit-min-device-pixel-ratio: 1.09375), (min-resolution: 105dpi), (min-resolution: 1.1dppx) { /* Serve SVG sprite if browser supports SVG and resolution is more than 105dpi */ .pswp--svg .pswp__button, .pswp--svg .pswp__button--arrow--left:before, .pswp--svg .pswp__button--arrow--right:before { background-image: url(default-skin.svg); } .pswp--svg .pswp__button--arrow--left, .pswp--svg .pswp__button--arrow--right { background: none; } } .pswp__button--close { background-position: 0 -44px; } .pswp__button--share { background-position: -44px -44px; } .pswp__button--fs { display: none; } .pswp--supports-fs .pswp__button--fs { display: block; } .pswp--fs .pswp__button--fs { background-position: -44px 0; } .pswp__button--zoom { display: none; background-position: -88px 0; } .pswp--zoom-allowed .pswp__button--zoom { display: block; } .pswp--zoomed-in .pswp__button--zoom { background-position: -132px 0; } /* no arrows on touch screens */ .pswp--touch .pswp__button--arrow--left, .pswp--touch .pswp__button--arrow--right { visibility: hidden; } /* Arrow buttons hit area (icon is added to :before pseudo-element) */ .pswp__button--arrow--left, .pswp__button--arrow--right { background: none; top: 50%; margin-top: -50px; width: 70px; height: 100px; position: absolute; } .pswp__button--arrow--left { left: 0; } .pswp__button--arrow--right { right: 0; } .pswp__button--arrow--left:before, .pswp__button--arrow--right:before { content: ''; top: 35px; background-color: rgba(0, 0, 0, 0.3); height: 30px; width: 32px; position: absolute; } .pswp__button--arrow--left:before { left: 6px; background-position: -138px -44px; } .pswp__button--arrow--right:before { right: 6px; background-position: -94px -44px; } /* 2. Share modal/popup and links */ .pswp__counter, .pswp__share-modal { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .pswp__share-modal { display: block; background: rgba(0, 0, 0, 0.5); width: 100%; height: 100%; top: 0; left: 0; padding: 10px; position: absolute; z-index: 1600; opacity: 0; -webkit-transition: opacity 0.25s ease-out; transition: opacity 0.25s ease-out; -webkit-backface-visibility: hidden; will-change: opacity; } .pswp__share-modal--hidden { display: none; } .pswp__share-tooltip { z-index: 1620; position: absolute; background: #FFF; top: 56px; border-radius: 2px; display: block; width: auto; right: 44px; -webkit-box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25); box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25); -webkit-transform: translateY(6px); -ms-transform: translateY(6px); transform: translateY(6px); -webkit-transition: -webkit-transform 0.25s; transition: transform 0.25s; -webkit-backface-visibility: hidden; will-change: transform; } .pswp__share-tooltip a { display: block; padding: 8px 12px; color: #000; text-decoration: none; font-size: 14px; line-height: 18px; } .pswp__share-tooltip a:hover { text-decoration: none; color: #000; } .pswp__share-tooltip a:first-child { /* round corners on the first/last list item */ border-radius: 2px 2px 0 0; } .pswp__share-tooltip a:last-child { border-radius: 0 0 2px 2px; } .pswp__share-modal--fade-in { opacity: 1; } .pswp__share-modal--fade-in .pswp__share-tooltip { -webkit-transform: translateY(0); -ms-transform: translateY(0); transform: translateY(0); } /* increase size of share links on touch devices */ .pswp--touch .pswp__share-tooltip a { padding: 16px 12px; } a.pswp__share--facebook:before { content: ''; display: block; width: 0; height: 0; position: absolute; top: -12px; right: 15px; border: 6px solid transparent; border-bottom-color: #FFF; -webkit-pointer-events: none; -moz-pointer-events: none; pointer-events: none; } a.pswp__share--facebook:hover { background: #3E5C9A; color: #FFF; } a.pswp__share--facebook:hover:before { border-bottom-color: #3E5C9A; } a.pswp__share--twitter:hover { background: #55ACEE; color: #FFF; } a.pswp__share--pinterest:hover { background: #CCC; color: #CE272D; } a.pswp__share--download:hover { background: #DDD; } /* 3. Index indicator ("1 of X" counter) */ .pswp__counter { position: absolute; left: 0; top: 0; height: 44px; font-size: 13px; line-height: 44px; color: #FFF; opacity: 0.75; padding: 0 10px; } /* 4. Caption */ .pswp__caption { position: absolute; left: 0; bottom: 0; width: 100%; min-height: 44px; } .pswp__caption small { font-size: 11px; color: #BBB; } .pswp__caption__center { text-align: left; max-width: 420px; margin: 0 auto; font-size: 13px; padding: 10px; line-height: 20px; color: #CCC; } .pswp__caption--empty { display: none; } /* Fake caption element, used to calculate height of next/prev image */ .pswp__caption--fake { visibility: hidden; } /* 5. Loading indicator (preloader) You can play with it here - http://codepen.io/dimsemenov/pen/yyBWoR */ .pswp__preloader { width: 44px; height: 44px; position: absolute; top: 0; left: 50%; margin-left: -22px; opacity: 0; -webkit-transition: opacity 0.25s ease-out; transition: opacity 0.25s ease-out; will-change: opacity; direction: ltr; } .pswp__preloader__icn { width: 20px; height: 20px; margin: 12px; } .pswp__preloader--active { opacity: 1; } .pswp__preloader--active .pswp__preloader__icn { /* We use .gif in browsers that don't support CSS animation */ background: url(preloader.gif) 0 0 no-repeat; } .pswp--css_animation .pswp__preloader--active { opacity: 1; } .pswp--css_animation .pswp__preloader--active .pswp__preloader__icn { -webkit-animation: clockwise 500ms linear infinite; animation: clockwise 500ms linear infinite; } .pswp--css_animation .pswp__preloader--active .pswp__preloader__donut { -webkit-animation: donut-rotate 1000ms cubic-bezier(0.4, 0, 0.22, 1) infinite; animation: donut-rotate 1000ms cubic-bezier(0.4, 0, 0.22, 1) infinite; } .pswp--css_animation .pswp__preloader__icn { background: none; opacity: 0.75; width: 14px; height: 14px; position: absolute; left: 15px; top: 15px; margin: 0; } .pswp--css_animation .pswp__preloader__cut { /* The idea of animating inner circle is based on Polymer ("material") loading indicator by Keanu Lee https://blog.keanulee.com/2014/10/20/the-tale-of-three-spinners.html */ position: relative; width: 7px; height: 14px; overflow: hidden; } .pswp--css_animation .pswp__preloader__donut { -webkit-box-sizing: border-box; box-sizing: border-box; width: 14px; height: 14px; border: 2px solid #FFF; border-radius: 50%; border-left-color: transparent; border-bottom-color: transparent; position: absolute; top: 0; left: 0; background: none; margin: 0; } @media screen and (max-width: 1024px) { .pswp__preloader { position: relative; left: auto; top: auto; margin: 0; float: right; } } @-webkit-keyframes clockwise { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); } } @keyframes clockwise { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); } } @-webkit-keyframes donut-rotate { 0% { -webkit-transform: rotate(0); transform: rotate(0); } 50% { -webkit-transform: rotate(-140deg); transform: rotate(-140deg); } 100% { -webkit-transform: rotate(0); transform: rotate(0); } } @keyframes donut-rotate { 0% { -webkit-transform: rotate(0); transform: rotate(0); } 50% { -webkit-transform: rotate(-140deg); transform: rotate(-140deg); } 100% { -webkit-transform: rotate(0); transform: rotate(0); } } /* 6. Additional styles */ /* root element of UI */ .pswp__ui { -webkit-font-smoothing: auto; visibility: visible; opacity: 1; z-index: 1550; } /* top black bar with buttons and "1 of X" indicator */ .pswp__top-bar { position: absolute; left: 0; top: 0; height: 44px; width: 100%; } .pswp__caption, .pswp__top-bar, .pswp--has_mouse .pswp__button--arrow--left, .pswp--has_mouse .pswp__button--arrow--right { -webkit-backface-visibility: hidden; will-change: opacity; -webkit-transition: opacity 333ms cubic-bezier(0.4, 0, 0.22, 1); transition: opacity 333ms cubic-bezier(0.4, 0, 0.22, 1); } /* pswp--has_mouse class is added only when two subsequent mousemove events occur */ .pswp--has_mouse .pswp__button--arrow--left, .pswp--has_mouse .pswp__button--arrow--right { visibility: visible; } .pswp__top-bar, .pswp__caption { background-color: rgba(0, 0, 0, 0.5); } /* pswp__ui--fit class is added when main image "fits" between top bar and bottom bar (caption) */ .pswp__ui--fit .pswp__top-bar, .pswp__ui--fit .pswp__caption { background-color: rgba(0, 0, 0, 0.3); } /* pswp__ui--idle class is added when mouse isn't moving for several seconds (JS option timeToIdle) */ .pswp__ui--idle .pswp__top-bar { opacity: 0; } .pswp__ui--idle .pswp__button--arrow--left, .pswp__ui--idle .pswp__button--arrow--right { opacity: 0; } /* pswp__ui--hidden class is added when controls are hidden e.g. when user taps to toggle visibility of controls */ .pswp__ui--hidden .pswp__top-bar, .pswp__ui--hidden .pswp__caption, .pswp__ui--hidden .pswp__button--arrow--left, .pswp__ui--hidden .pswp__button--arrow--right { /* Force paint & create composition layer for controls. */ opacity: 0.001; } /* pswp__ui--one-slide class is added when there is just one item in gallery */ .pswp__ui--one-slide .pswp__button--arrow--left, .pswp__ui--one-slide .pswp__button--arrow--right, .pswp__ui--one-slide .pswp__counter { display: none; } .pswp__element--disabled { display: none !important; } .pswp--minimal--dark .pswp__top-bar { background: none; }]]></content>
  </entry>
</search>
